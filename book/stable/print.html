<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GUI development with Relm4</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="basic_concepts/index.html"><strong aria-hidden="true">1.</strong> Basic concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic_concepts/model.html"><strong aria-hidden="true">1.1.</strong> Model</a></li><li class="chapter-item expanded "><a href="basic_concepts/messages.html"><strong aria-hidden="true">1.2.</strong> Messages</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic_concepts/messages/input.html"><strong aria-hidden="true">1.2.1.</strong> Input</a></li><li class="chapter-item expanded "><a href="basic_concepts/messages/output.html"><strong aria-hidden="true">1.2.2.</strong> Output</a></li></ol></li><li class="chapter-item expanded "><a href="basic_concepts/widgets.html"><strong aria-hidden="true">1.3.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="basic_concepts/components.html"><strong aria-hidden="true">1.4.</strong> Components</a></li></ol></li><li class="chapter-item expanded "><a href="first_app.html"><strong aria-hidden="true">2.</strong> Your first app</a></li><li class="chapter-item expanded "><a href="component_macro.html"><strong aria-hidden="true">3.</strong> The component macro</a></li><li class="chapter-item expanded "><a href="tricks.html"><strong aria-hidden="true">4.</strong> Tips and tricks</a></li><li class="chapter-item expanded "><a href="efficient_ui/index.html"><strong aria-hidden="true">5.</strong> Efficient UI updates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="efficient_ui/tracker.html"><strong aria-hidden="true">5.1.</strong> Tracker</a></li><li class="chapter-item expanded "><a href="efficient_ui/factory.html"><strong aria-hidden="true">5.2.</strong> Factories</a></li><li class="chapter-item expanded "><a href="efficient_ui/factory_position.html"><strong aria-hidden="true">5.3.</strong> The position function</a></li></ol></li><li class="chapter-item expanded "><a href="components.html"><strong aria-hidden="true">6.</strong> Components</a></li><li class="chapter-item expanded "><a href="threads_and_async/index.html"><strong aria-hidden="true">7.</strong> Threads and async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threads_and_async/worker.html"><strong aria-hidden="true">7.1.</strong> Workers</a></li><li class="chapter-item expanded "><a href="threads_and_async/commands.html"><strong aria-hidden="true">7.2.</strong> Commands</a></li><li class="chapter-item expanded "><a href="threads_and_async/async.html"><strong aria-hidden="true">7.3.</strong> Async components and factories</a></li><li class="chapter-item expanded "><a href="threads_and_async/overview.html"><strong aria-hidden="true">7.4.</strong> Overview</a></li></ol></li><li class="chapter-item expanded "><a href="child_components.html"><strong aria-hidden="true">8.</strong> Child components</a></li><li class="chapter-item expanded "><a href="widget_templates/index.html"><strong aria-hidden="true">9.</strong> Widget templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="widget_templates/accessing_nested_template_elements.html"><strong aria-hidden="true">9.1.</strong> Accessing Nested Template Elements</a></li></ol></li><li class="chapter-item expanded "><a href="gtk_rs.html"><strong aria-hidden="true">10.</strong> gtk-rs overview</a></li><li class="chapter-item expanded "><a href="resource_bundles.html"><strong aria-hidden="true">11.</strong> Resource Bundles</a></li><li class="chapter-item expanded "><a href="continuous_integration.html"><strong aria-hidden="true">12.</strong> Continuous Integration guide</a></li><li class="chapter-item expanded "><a href="component_macro/reference.html"><strong aria-hidden="true">13.</strong> Component macro reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="component_macro/expansion.html"><strong aria-hidden="true">13.1.</strong> Macro expansion</a></li></ol></li><li class="chapter-item expanded "><a href="migrations/index.html"><strong aria-hidden="true">14.</strong> Migration guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="migrations/0_2_to_0_4.html"><strong aria-hidden="true">14.1.</strong> 0.2 to 0.4</a></li><li class="chapter-item expanded "><a href="migrations/0_4_to_0_5.html"><strong aria-hidden="true">14.2.</strong> 0.4 to 0.5</a></li><li class="chapter-item expanded "><a href="migrations/0_5_to_0_6.html"><strong aria-hidden="true">14.3.</strong> 0.5 to 0.6</a></li><li class="chapter-item expanded "><a href="migrations/0_6_to_0_7.html"><strong aria-hidden="true">14.4.</strong> 0.6 to 0.7</a></li><li class="chapter-item expanded "><a href="migrations/0_7_to_0_8.html"><strong aria-hidden="true">14.5.</strong> 0.7 to 0.8</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Relm4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Relm4/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1>
  <a href="https://relm4.org">
    <img src="img/Relm_logo_with_text.png" width="190" alt="Relm4">
  </a>
</h1>
<p><a href="https://matrix.to/#/#relm4:matrix.org"><img src="https://img.shields.io/matrix/relm4:matrix.org?label=matrix%20chat" alt="Matrix" /></a>
<a href="https://crates.io/crates/relm4"><img src="https://img.shields.io/crates/v/relm4.svg" alt="Relm4 on crates.io" /></a>
<a href="https://docs.rs/relm4/latest/relm4/"><img src="https://img.shields.io/badge/rust-documentation-blue" alt="Relm4 docs" /></a></p>
<p>Relm4 is an idiomatic GUI library inspired by <a href="https://elm-lang.org/">Elm</a> and based on <a href="https://crates.io/crates/gtk4">gtk4-rs</a>.
It is a new version of <a href="https://github.com/antoyo/relm">relm</a> that's built from scratch and is compatible with <a href="https://www.gtk.org/">GTK4</a> and <a href="https://gitlab.gnome.org/GNOME/libadwaita">libadwaita</a>.</p>
<!--
### Visit the [book of the upcoming version](/book/next)!
-->
<h2 id="why-relm4"><a class="header" href="#why-relm4">Why Relm4</a></h2>
<p>We believe that GUI development should be easy, productive and delightful.<br />
The <a href="https://crates.io/crates/gtk4">gtk4-rs</a> crate already provides everything you need to write modern, beautiful and cross-platform applications.
Built on top of this foundation, Relm4 makes developing more idiomatic, simpler and faster and enables you to become productive in just a few hours.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>To work with Relm4, you should understand most basic language features of the Rust programming language. We recommend to at least be familiar with the content of the chapters 1, 3-6, 8, 10 and 13 of the <a href="https://doc.rust-lang.org/stable/book/title-page.html">Rust book</a>.</p>
<p>I also recommend reading the <a href="https://gtk-rs.org/gtk4-rs/git/book/">gtk4-rs book</a> for getting more insight into development with gtk4-rs. Yet, knowledge of GTK4 or gtk4-rs is not required in this book.</p>
<p><strong>Helpful links:</strong></p>
<ul>
<li><a href="https://gtk-rs.org/gtk4-rs/git/book/installation.html">How to install GTK4 for Rust</a></li>
<li><a href="https://gtk-rs.org/gtk4-rs/git/book/">gtk4-rs book</a></li>
<li><a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/index.html">gtk4-rs docs</a></li>
</ul>
<p><strong>Cargo:</strong></p>
<p>Add the packages you need to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">relm4 = "0.8.0"
relm4-components = "0.8.0"
</code></pre>
<h2 id="issues-and-feedback"><a class="header" href="#issues-and-feedback">Issues and feedback</a></h2>
<p>If you find a mistake or something unclear in Relm4 or this book, let us know! Simply open up an <a href="https://github.com/Relm4/Relm4/issues">issue</a> or start a <a href="https://github.com/Relm4/Relm4/discussions">discussion</a> over at <a href="https://github.com/Relm4/Relm4">GitHub</a> or chat with us on <a href="https://matrix.to/#/#relm4:matrix.org">Matrix</a>.</p>
<h2 id="platform-support"><a class="header" href="#platform-support">Platform support</a></h2>
<p>All platforms supported by GTK4 are available for Relm4 as well:</p>
<ul>
<li>Linux</li>
<li>Windows</li>
<li>macOS</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>If you prefer learning directly from examples, we got you covered!</p>
<p>Many code examples in this book and many other examples can also be found in the <a href="https://github.com/Relm4/Relm4/tree/main/examples">git-repository</a>. Whenever an example is discussed in the book, the introduction will mention the name of the example and provide a link to it.</p>
<p>To setup the examples run</p>
<pre><code class="language-bash">git clone https://github.com/Relm4/Relm4.git
</code></pre>
<p>And to run an example, simply type</p>
<pre><code>cargo run --example NAME
</code></pre>
<p>To get a list of all examples, run</p>
<pre><code>cargo run --example
</code></pre>
<h3 id="screenshots"><a class="header" href="#screenshots">Screenshots</a></h3>
<p>As a sneak peak here are screenshots of some examples.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Light Theme</th><th style="text-align: center">Dark Theme</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/screenshots/popover-light.png" alt="Pop Over light" /></td><td style="text-align: center"><img src="img/screenshots/popover-dark.png" alt="Pop Over dark" /></td></tr>
<tr><td style="text-align: center"><img src="img/screenshots/factory-advanced-light.png" alt="Factory-Advanced light" /></td><td style="text-align: center"><img src="img/screenshots/factory-advanced-dark.png" alt="Factory-Advanced dark" /></td></tr>
</tbody></table>
</div>
<h1 id="special-thanks"><a class="header" href="#special-thanks">Special thanks</a></h1>
<p>We want to thank all contributors of <a href="https://github.com/antoyo/relm">relm</a> especially <a href="https://github.com/antoyo">antoyo</a> for building relm that inspired much of the work on Relm4.</p>
<p>Also, we want to thank all contributors of <a href="https://gtk-rs.org/">gtk-rs</a> that put a lot of effort into the project for creating outstanding Rust bindings for GTK4.</p>
<p>We want to thank <a href="https://github.com/tronta">tronta</a>, <a href="https://github.com/edfloreshz"> Eduardo Flores</a>, <a href="https://github.com/euclio">Andy Russell</a>, <a href="https://github.com/AaronErhardt">Aaron Erhardt</a> for contributing a lot of improvements to this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic concepts</a></h1>
<p>Before we start building our app, we need to understand the basic concepts of Relm4. If you have experience with GTK and Rust, you will probably breeze through this section, but if you don't, this section is for you.</p>
<p>We will explain in detail how Relm4 works and how to use it.
After this section, we will be building a simple counter app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model"><a class="header" href="#model">Model</a></h1>
<p>Like a person, a computer needs a brain to be functional. It needs to process our messages and remember the results.</p>
<p>Relm4 uses the term model as a data type that represents the application state, the memory of your application.</p>
<p>For example, to store a counter value, we can store a <code>u8</code> in our model:</p>
<pre><code class="language-rust no_run noplayground">struct AppModel {
    counter: u8,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messages"><a class="header" href="#messages">Messages</a></h1>
<p>To help the computer understand what we want to tell it, we first translate user interactions into messages.</p>
<p>In Relm4, a message can be any data type, but most often, an <code>enum</code> is used.</p>
<pre><code class="language-rust no_run noplayground">enum AppInput {
    Increment,
    Decrement,
}</code></pre>
<p>Computers are capable of both sending and receiving messages and similarly, components in Relm4 can send and receive messages.</p>
<p>This is accomplished by having two types of messages: <code>Input</code> and <code>Output</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-messages"><a class="header" href="#input-messages">Input messages</a></h1>
<p>Input messages are a way for our components to receive information, think of them as our inbox 📬.</p>
<p>Let's look at it with a simple <code>MailboxComponent</code> example:</p>
<p>We have our <code>Inbox</code>, capable of receiving emails from other people.</p>
<pre><code class="language-rust no_run noplayground">enum Inbox {
    GetEmail(Email),
}</code></pre>
<p>These messages are received by our component and handled in the <code>update</code> function.</p>
<pre><code class="language-rust no_run noplayground">fn update(&amp;mut self, message: Self::Input, ...) {
    match message {
        Inbox::GetEmail(email) =&gt; self.emails.push(email)
    }
}</code></pre>
<p>Our <code>MailboxComponent</code> can not only receive emails from other people, but we can also send emails to ourselves.</p>
<p>Components work in the same way, they can either receive messages from other components or send themselves messages to update their own model.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-messages"><a class="header" href="#output-messages">Output messages</a></h1>
<p>Output messages are sent by components to other components and handled differently depending on the type of components that receives them. We can think of them as our outbox 🚚.</p>
<p>Let's take our previous <code>MailboxComponent</code> example and add the following.</p>
<pre><code class="language-rust no_run noplayground">enum Outbox {
    SendEmail(Email),
}</code></pre>
<p>We can modify our previous example for forward the emails to somebody else.</p>
<pre><code class="language-rust no_run noplayground">fn update(&amp;mut self, message: Self::Input, sender: ComponentSender&lt;Self&gt;) {
    match message {
        Inbox::GetEmail(email) =&gt; sender.output(Outbox::SendEmail(email)),
    }
}</code></pre>
<p>Usually, output messages are handled by the parent component, which is the component that creates and stores our <code>MailboxComponent</code>.
You can think of it like a tree with one component at the root and many child components that branch out.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>GTK4 provides <a href="https://docs.gtk.org/gtk4/visual_index.html">widgets</a> as building blocks for your UI, like buttons, input fields or text areas.
They can visualize data and also receive user inputs.
In Relm4, user inputs are usually directly translated into input messages for our components.</p>
<p>It's important to understand that widgets behave similar to <a href="https://doc.rust-lang.org/std/rc/index.html"><code>Rc</code></a>.
Most importantly, this means that:</p>
<ul>
<li>Cloning a widget doesn't create a new instance, but just increases the reference count.</li>
<li>Widgets are kept alive automatically. Dropping widgets that are still used somewhere does not destroy them, but just decreases the reference count.</li>
<li>Widgets are not thread-safe. Widgets don't implement <code>Send</code> and can only be used on the main thread.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>Components are the fundamental building blocks of Relm4. To create a component you need to implement the <code>Component</code> trait.</p>
<h2 id="the-component-trait"><a class="header" href="#the-component-trait">The <code>Component</code> trait</a></h2>
<p>The <code>Component</code> trait is the base of every component inside Relm4, it defines how a component should behave, communicate and produce widgets.</p>
<h2 id="the-simplecomponent-trait"><a class="header" href="#the-simplecomponent-trait">The <code>SimpleComponent</code> trait</a></h2>
<p>The <code>SimpleComponent</code> trait is a convenience trait that implements the <code>Component</code> trait, but removes some advanced features that are not relevant for most use-cases.</p>
<p>For each implementation of <code>SimpleComponent</code>, Relm4 will automatically implement <code>Component</code> as well. Thus, it can also be used instead of <code>Component</code>. This mechanism is called <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods">blanket implementation</a> and is used for traits like <code>From</code> in the standard library as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-app"><a class="header" href="#your-first-app">Your first app</a></h1>
<p>For our first app, let's create something original: a <strong>counter app</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>GTK Light</th><th>GTK Dark</th></tr></thead><tbody>
<tr><td><img src="img/screenshots/simple-light.png" alt="App screenshot light" /></td><td><img src="img/screenshots/simple-dark.png" alt="App screenshot dark" /></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Adwaita Light</th><th>Adwaita Dark</th></tr></thead><tbody>
<tr><td><img src="img/screenshots/simple-light-adw.png" alt="App screenshot light adw" /></td><td><img src="img/screenshots/simple-dark-adw.png" alt="App screenshot dark adw" /></td></tr>
</tbody></table>
</div>
<p>In this app, we will have a counter which can be incremented and decremented by pressing the corresponding buttons.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/Relm4/Relm4/blob/main/examples/simple_manual.rs">here</a>. Run <code>cargo run --example simple_manual</code> from the <a href="https://github.com/Relm4/Relm4/tree/main/examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="application-architecture"><a class="header" href="#application-architecture">Application architecture</a></h2>
<p>Often, programming concepts are easier to understand when explained with examples or metaphors from the real world. To understand how Relm4 apps work, you can think about a computer as a person.</p>
<p>Our job as a programmer is to ensure that the users of our app will be able to communicate with the computer through the UI. Since the computer can't understand our human language, it needs some help from us to get the communication going.</p>
<p>Let's have a look at what we need to get this done!</p>
<h3 id="messages-1"><a class="header" href="#messages-1">Messages</a></h3>
<p>For our app, we just want to tell the computer to either increment or decrement a counter.</p>
<pre><code class="language-rust no_run noplayground">enum AppInput {
    Increment,
    Decrement,
}</code></pre>
<h3 id="the-model"><a class="header" href="#the-model">The model</a></h3>
<p>For our counter app, the computer only needs to remember the counter value, so an <code>u8</code> is all we need.</p>
<pre><code class="language-rust no_run noplayground">struct AppModel {
    counter: u8,
}</code></pre>
<h3 id="the-widgets"><a class="header" href="#the-widgets">The widgets</a></h3>
<p>GTK4 offers the computer widgets that allow it to take input and to respond. Widgets are simply parts of an UI like buttons, input fields or text areas. To be able to update the widgets in our program, we can put them all into a <code>struct</code>.</p>
<p>For our application, we use a window with two buttons to increase and decrease the counter and a label to display the counter value. We also need a box as a container to house our buttons and label, since a window can only have one child.</p>
<p>In our case, we will only update the label when we increment or decrement the counter, so we don't really need to store everything inside the struct.</p>
<pre><code class="language-rust no_run noplayground">struct AppWidgets {
    label: gtk::Label,
}</code></pre>
<p>Although, if you want to, you can.</p>
<h3 id="implement-a-component-with-simplecomponent"><a class="header" href="#implement-a-component-with-simplecomponent">Implement a component with <code>SimpleComponent</code>.</a></h3>
<p>The last step we need is to tell the computer how to initialize and update the widgets.</p>
<p>All that is left to do is to implement the <code>SimpleComponent</code> trait for your model, which tells the computer exactly how to visualize its memory.</p>
<p>Let's do this step by step. First, we'll have a look at the beginning of the trait <code>impl</code>.</p>
<pre><code class="language-rust no_run noplayground">impl SimpleComponent for AppModel {</code></pre>
<p>The first thing you need to do is to define some generic types necessary to make our component work.</p>
<pre><code class="language-rust no_run noplayground">    /// The type of the messages that this component can receive.
    type Input = AppInput;
    /// The type of the messages that this component can send.
    type Output = ();
    /// The type of data with which this component will be initialized.
    type Init = u8;
    /// The root GTK widget that this component will create.
    type Root = gtk::Window;
    /// A data structure that contains the widgets that you will need to update.
    type Widgets = AppWidgets;</code></pre>
<p>The types defined in the trait tell our component how it should communicate with other components and what type of widgets should be produced.</p>
<p>The <code>Root</code> type is the outermost widget of the app. Components can choose this type freely, but the main component must use a <code>Window</code>.</p>
<p>Since the window widget is our root widget, we are going to create it in the <code>init_root</code> function.</p>
<pre><code class="language-rust no_run noplayground">    fn init_root() -&gt; Self::Root {
        gtk::Window::builder()
            .title("Simple app")
            .default_width(300)
            .default_height(100)
            .build()
    }</code></pre>
<p>Next up, we want to initialize our UI and the model.</p>
<blockquote>
<p>Don't worry about the amount of manual code you need for handling widgets. In the next chapter, we'll see how this can be done easier.</p>
</blockquote>
<p>All of these widgets will be created in the <code>init</code> function. We get our <code>Root</code> window and the <code>Init</code> variables to create our widgets with.</p>
<pre><code class="language-rust no_run noplayground">    /// Initialize the UI and model.
    fn init(
        counter: Self::Init,
        window: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; relm4::ComponentParts&lt;Self&gt; {
        let model = AppModel { counter };

        let vbox = gtk::Box::builder()
            .orientation(gtk::Orientation::Vertical)
            .spacing(5)
            .build();

        let inc_button = gtk::Button::with_label("Increment");
        let dec_button = gtk::Button::with_label("Decrement");

        let label = gtk::Label::new(Some(&amp;format!("Counter: {}", model.counter)));
        label.set_margin_all(5);

        window.set_child(Some(&amp;vbox));
        vbox.set_margin_all(5);
        vbox.append(&amp;inc_button);
        vbox.append(&amp;dec_button);
        vbox.append(&amp;label);

        inc_button.connect_clicked(clone!(@strong sender =&gt; move |_| {
            sender.input(AppInput::Increment);
        }));

        dec_button.connect_clicked(clone!(@strong sender =&gt; move |_| {
            sender.input(AppInput::Decrement);
        }));

        let widgets = AppWidgets { label };

        ComponentParts { model, widgets }
    }</code></pre>
<p>First, we initialize each of our widgets, mostly by using builder patterns.</p>
<p>Then we connect the widgets so that GTK4 knows how they are related to each other. The buttons and the label are added as children of the box, and the box is added as the child of the window.</p>
<p>Next, we connect the "clicked" event for both buttons and send a message from the closures to the computer. To do this, we only need to move a cloned sender into the closures and send the message. Now every time we click our buttons, a message will be sent to update our counter!</p>
<p>Of course, the computer needs to do more than just remembering things, it also needs to process information. Here, both the model and message types come into play.</p>
<p>The <code>update</code> function of the <code>SimpleComponent</code> trait tells the computer how to process messages and how to update its memory.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;mut self, message: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match message {
            AppInput::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppInput::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
    }</code></pre>
<blockquote>
<p><code>wrapping_add(1)</code> and <code>wrapping_sub(1)</code> are like <code>+1</code>  and <code>-1</code>, but don't panic on overflows.</p>
</blockquote>
<p>We see that the <code>update</code> function receives a message and updates the model according to your instructions.</p>
<p>Still our UI will not update when the counter is changed. To do this, we need to implement the <code>update_view</code> function that modifies the UI according to the changes in the model.</p>
<pre><code class="language-rust no_run noplayground">    /// Update the view to represent the updated model.
    fn update_view(&amp;self, widgets: &amp;mut Self::Widgets, _sender: ComponentSender&lt;Self&gt;) {
        widgets
            .label
            .set_label(&amp;format!("Counter: {}", self.counter));
    }</code></pre>
<h2 id="running-the-app"><a class="header" href="#running-the-app">Running the App</a></h2>
<p>The last step is to run the app we just wrote. To do so, we just need to initialize our model and pass it into <code>RelmApp::new()</code>.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    let app = RelmApp::new("relm4.test.simple_manual");
    app.run::&lt;AppModel&gt;(0);
}</code></pre>
<p>🎉 Congratulations! You just wrote your first app with Relm4! 🎉</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Let's summarize what we learned in this chapter.</p>
<p>A Relm4 application has three important types:</p>
<ol>
<li>The model type that stores the application state, the memory of our app.</li>
<li>The message type that describes which information can be sent to update the model.</li>
<li>The widgets type that stores our widgets.</li>
</ol>
<p>Also, there are two important functions:</p>
<ol>
<li><code>update</code> receives a message and updates the model accordingly.</li>
<li><code>update_view</code> receives the updated model and updates the widgets accordingly.</li>
</ol>
<p>The app does all those things in a loop. It waits for messages and once a message is received, it runs <code>update</code> and then <code>view</code>.</p>
<p><img src="img/update_loop.svg" alt="relm update loop" /></p>
<blockquote>
<p>Relm4 separates the data and the UI. The UI never knows which message was sent, but can only read the model. This might seem like a limitation, but it helps you to create maintainable, stable and consistent applications.</p>
</blockquote>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>I hope this chapter made everything clear for you :)</p>
<p>If you found a mistake or there was something unclear, please open an issue <a href="https://github.com/Relm4/Relm4/issues">here</a>.</p>
<p>As you have seen, initializing the UI was by far the largest part of our app, with roughly one half of the total code. In the next chapter, we will have a look at the <code>relm4-macros</code> crate, which provides a macro that helps us reduce the amount of code we need to implement the Widgets trait.</p>
<blockquote>
<p>As you might have noticed, storing <code>inc_button</code>, <code>dec_button</code> and <code>vbox</code> in our widgets <code>struct</code> is not necessary because GTK will keep them alive automatically. Therefore, we can remove them from <code>AppWidgets</code> to avoid compiler warnings.</p>
</blockquote>
<h2 id="the-complete-code"><a class="header" href="#the-complete-code">The complete code</a></h2>
<p>Let's review our code in one piece to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::glib::clone;
use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt};
use relm4::{gtk, ComponentParts, ComponentSender, RelmApp, RelmWidgetExt, SimpleComponent};

struct AppModel {
    counter: u8,
}

#[derive(Debug)]
enum AppInput {
    Increment,
    Decrement,
}

struct AppWidgets {
    label: gtk::Label,
}

impl SimpleComponent for AppModel {

    /// The type of the messages that this component can receive.
    type Input = AppInput;
    /// The type of the messages that this component can send.
    type Output = ();
    /// The type of data with which this component will be initialized.
    type Init = u8;
    /// The root GTK widget that this component will create.
    type Root = gtk::Window;
    /// A data structure that contains the widgets that you will need to update.
    type Widgets = AppWidgets;

    fn init_root() -&gt; Self::Root {
        gtk::Window::builder()
            .title("Simple app")
            .default_width(300)
            .default_height(100)
            .build()
    }

    /// Initialize the UI and model.
    fn init(
        counter: Self::Init,
        window: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; relm4::ComponentParts&lt;Self&gt; {
        let model = AppModel { counter };

        let vbox = gtk::Box::builder()
            .orientation(gtk::Orientation::Vertical)
            .spacing(5)
            .build();

        let inc_button = gtk::Button::with_label("Increment");
        let dec_button = gtk::Button::with_label("Decrement");

        let label = gtk::Label::new(Some(&amp;format!("Counter: {}", model.counter)));
        label.set_margin_all(5);

        window.set_child(Some(&amp;vbox));
        vbox.set_margin_all(5);
        vbox.append(&amp;inc_button);
        vbox.append(&amp;dec_button);
        vbox.append(&amp;label);

        inc_button.connect_clicked(clone!(@strong sender =&gt; move |_| {
            sender.input(AppInput::Increment);
        }));

        dec_button.connect_clicked(clone!(@strong sender =&gt; move |_| {
            sender.input(AppInput::Decrement);
        }));

        let widgets = AppWidgets { label };

        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, message: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match message {
            AppInput::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppInput::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
    }

    /// Update the view to represent the updated model.
    fn update_view(&amp;self, widgets: &amp;mut Self::Widgets, _sender: ComponentSender&lt;Self&gt;) {
        widgets
            .label
            .set_label(&amp;format!("Counter: {}", self.counter));
    }
}

fn main() {
    let app = RelmApp::new("relm4.test.simple_manual");
    app.run::&lt;AppModel&gt;(0);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-component-macro"><a class="header" href="#the-component-macro">The component macro</a></h1>
<p>To simplify the implementation of the <code>Component</code> trait, let's use the relm4-macros crate!</p>
<p><img src="img/screenshots/simple-dark.png" alt="App screenshot dark" /></p>
<p>The app will look and behave identically to our first app from the previous chapter. Only the implementation is different.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/Relm4/Relm4/blob/main/examples/simple.rs">here</a>. Run <code>cargo run --example simple</code> from the <a href="https://github.com/Relm4/Relm4/tree/main/examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="whats-different"><a class="header" href="#whats-different">What's different</a></h2>
<p>The <code>component</code> macro will simplify creating the <code>Widgets</code> <code>struct</code>. The update code remains untouched, so we can reuse most of the code from the previous chapter.</p>
<p>Let's have a look at how to define a component with the macro and go through the code step by step:</p>
<pre><code class="language-rust no_run noplayground">#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = u8;

    type Input = AppMsg;
    type Output = ();

    view! {
        gtk::Window {
            set_title: Some("Simple app"),
            set_default_width: 300,
            set_default_height: 100,

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,
                set_spacing: 5,
                set_margin_all: 5,

                gtk::Button {
                    set_label: "Increment",
                    connect_clicked =&gt; AppMsg::Increment
                },

                gtk::Button::with_label("Decrement") {
                    connect_clicked =&gt; AppMsg::Decrement
                },

                gtk::Label {
                    #[watch]
                    set_label: &amp;format!("Counter: {}", model.counter),
                    set_margin_all: 5,
                }
            }
        }
    }

    // Initialize the UI.
    fn init(
        counter: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let model = AppModel { counter };

        // Insert the macro code generation here
        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
    }
}</code></pre>
<p>The associated types don't change. We still have to define the model, the input parameters, and the message types. However, the <code>Widgets</code> type is never explicitly defined in the code, but generated by the macro.</p>
<p>And then... wait, where do we define the <code>Root</code> type? Actually, the macro knows that the outermost widget becomes automatically the root widget.</p>
<p>Next up - the heart of the <code>component</code> macro - the nested <code>view!</code> macro. Here, we can easily define widgets and assign properties to them.</p>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<p>As you see, we start with the <code>gtk::Window</code> which is our root. Then we open up brackets and assign properties to the window. There's not much magic here but actually <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/prelude/trait.GtkWindowExt.html#tymethod.set_title"><code>set_title</code></a> is a method provided by gtk4-rs. So technically, the macro creates code like this:</p>
<pre><code class="language-rust no_run noplayground">window.set_title(Some("Simple app"));</code></pre>
<h3 id="widgets-1"><a class="header" href="#widgets-1">Widgets</a></h3>
<p>We assign a child to the window by nesting another widget inside it. Widgets may be nested indefinitely:</p>
<pre><code class="language-rust no_run noplayground">            gtk::Box {</code></pre>
<p>Sometimes we want to use a constructor function to initialize our widgets. For the second button we used the <code>gtk::Button::with_label</code> function. This function returns a new button with the "Decrement" label already set, so we don't have to call <code>set_label</code> afterwards.</p>
<pre><code class="language-rust no_run noplayground">                gtk::Button::with_label("Decrement") {</code></pre>
<h3 id="events"><a class="header" href="#events">Events</a></h3>
<p>To connect events, we use this general syntax:</p>
<pre><code class="language-rust no_run noplayground">method_name[cloned_var1, cloned_var2, ...] =&gt; move |args, ...| { code... }</code></pre>
<p>Again, there's no magic. The macro will simply assign a closure to a method. Because closures often need to capture local variables that don't implement the <code>Copy</code> trait, we need to clone these variables. Therefore, we can list the variables we want to clone in the square brackets after the method name.</p>
<p>For simple cases there's even a shorter syntax for just sending one input message that works with most event handlers.
So instead of this:</p>
<pre><code class="language-rust no_run noplayground">method_name[sender] =&gt; move |_| { sender.input(Msg); },</code></pre>
<p>You can simply write this:</p>
<pre><code class="language-rust no_run noplayground">method_name =&gt; Msg,</code></pre>
<p>This is what we used in this example:</p>
<pre><code class="language-rust no_run noplayground">                    connect_clicked =&gt; AppMsg::Decrement</code></pre>
<h3 id="ui-updates"><a class="header" href="#ui-updates">UI updates</a></h3>
<p>The last special syntax of the <code>component</code> macro we'll cover here is the <code>#[watch]</code> attribute. It's just like the normal initialization except that it also updates the property in the view function. Without it, the counter label would never be updated.</p>
<pre><code class="language-rust no_run noplayground">                    #[watch]
                    set_label: &amp;format!("Counter: {}", model.counter),</code></pre>
<blockquote>
<p>The full reference for the syntax of the widget macro can be found <a href="component_macro/reference.html">here</a>.</p>
</blockquote>
<h2 id="constructing-the-widgets"><a class="header" href="#constructing-the-widgets">Constructing the Widgets</a></h2>
<p>After we've defined our widgets, we need to construct them. This is done with the <code>view_output!</code> macro, which returns a fully-initialized instance of our <code>Widgets</code> struct.</p>
<pre><code class="language-rust no_run noplayground">        // Insert the macro code generation here
        let widgets = view_output!();</code></pre>
<h2 id="the-complete-code-1"><a class="header" href="#the-complete-code-1">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt, OrientableExt};
use relm4::{gtk, ComponentParts, ComponentSender, RelmApp, RelmWidgetExt, SimpleComponent};

struct AppModel {
    counter: u8,
}

#[derive(Debug)]
enum AppMsg {
    Increment,
    Decrement,
}

#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = u8;

    type Input = AppMsg;
    type Output = ();

    view! {
        gtk::Window {
            set_title: Some("Simple app"),
            set_default_width: 300,
            set_default_height: 100,

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,
                set_spacing: 5,
                set_margin_all: 5,

                gtk::Button {
                    set_label: "Increment",
                    connect_clicked =&gt; AppMsg::Increment
                },

                gtk::Button::with_label("Decrement") {
                    connect_clicked =&gt; AppMsg::Decrement
                },

                gtk::Label {
                    #[watch]
                    set_label: &amp;format!("Counter: {}", model.counter),
                    set_margin_all: 5,
                }
            }
        }
    }

    // Initialize the UI.
    fn init(
        counter: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let model = AppModel { counter };

        // Insert the macro code generation here
        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
    }
}

fn main() {
    let app = RelmApp::new("relm4.test.simple");
    app.run::&lt;AppModel&gt;(0);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and tricks</a></h1>
<p>This chapter comes quite early in the book because it is quite helpful for beginners, but is certainly also useful for more advanced users.
It  contains the most common tips and tricks you will need while using Relm4.
In case you have a problem, you can simply return to this chapter and might find something helpful very quickly.
We recommend to have at least a short look at this chapter, but there's no crucial information in here so you can already continue with the next chapter if you want.</p>
<h2 id="advanced-view-macro-features"><a class="header" href="#advanced-view-macro-features">Advanced view macro features</a></h2>
<p>Some features of the view macro are explained very late in the book and are easy to overlook.
Here's a short summery of those features, which you might find useful.
If you found something interesting, you can look for more details in the <a href="./component_macro/reference.html">macro reference chapter</a>.</p>
<ul>
<li>Initialization using a builder pattern</li>
<li>Pass additional arguments</li>
<li>Pass <code>Some(widget)</code></li>
<li><code>if</code> and <code>match</code> statements to dynamically select visible widgets</li>
<li>Use the return value of assignments</li>
<li>Optional and iterative assignments</li>
</ul>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common pitfalls</a></h2>
<p>The Elm architecture itself is pretty simple, but as your application grows, small oversights can sometimes cause large problems.</p>
<h3 id="message-recursion"><a class="header" href="#message-recursion">Message recursion</a></h3>
<p>Relm4 components use a simple update loop: Receive a message, update the model and then update the view.
Usually, this works as intended, but if updating the view somehow creates a new, identical message, your code will be stuck in an infinite loop and your app will freeze.
To prevent this, the view macro has the <code>block_signal</code> attribute which is explained <a href="./component_macro/reference.html#blocking-signals-temporarily">here</a>.</p>
<h3 id="sending-errors"><a class="header" href="#sending-errors">Sending errors</a></h3>
<p>Sending messages in Relm4 can lead to panics under certain circumstances.
The most common mistake is dropping a <code>Controller</code>.
This will cause the entire runtime of the component to be dropped together with all it's receivers.
Sending message to this component afterwards will not work because the receiving side is not available anymore.
To avoid this problem, you can either store the <code>Controller</code> in the model of its parent components or call <a href="https://docs.rs/relm4/latest/relm4/component/struct.Controller.html#method.detach_runtime"><code>detach_runtime()</code></a>.</p>
<p>Also note that sending output messages will not work if you <a href="https://docs.rs/relm4/latest/relm4/component/struct.Connector.html#method.detach"><code>detach</code></a> a component, again because this means that no receiver is available.
In this case it might be desired to ignore sending errors.</p>
<h2 id="common-compiler-errors"><a class="header" href="#common-compiler-errors">Common compiler errors</a></h2>
<p>Relm4's macros try to make your life easier, but sometimes the created error messages are rather confusing.
This is not something that can be fully fixed in the macro itself due to the limitations of the Rust programming language, but we try to summarize some common errors in this section.</p>
<h3 id="private-type-in-public-interface"><a class="header" href="#private-type-in-public-interface">Private type in public interface</a></h3>
<p>The <code>#[component]</code> and <code>#[factory]</code> macros will automatically generate a struct for storing your widgets.
This struct must have the same visibility as the model because it is associated with the <code>Component</code> or <code>FactoryComponent</code> implementation of the model.
To tell the macro to generate a public widgets type, you can simply use <code>#[component(pub)]</code> or <code>#[factory(pub)]</code>.</p>
<h3 id="method-container_add-is-missing"><a class="header" href="#method-container_add-is-missing">Method <code>container_add</code> is missing</a></h3>
<p>Relm4 implements the <a href="https://docs.rs/relm4/latest/relm4/trait.RelmContainerExt.html#tymethod.container_add"><code>ContainerExt</code></a> trait for many widgets that allows you simply nest widgets in the view macro.</p>
<pre><code class="language-rust ignore">gtk::Box {
    gtk::Label {
        // ...
    }
}</code></pre>
<p>Unfortunately, this trait can't always be implemented because some widgets don't have a obvious method for adding children.
For <code>gtk::Box</code> it is relatively simple and just uses the <code>append()</code> method internally.
However, <code>gtk::Header</code> has three possible locations to add children: start, center and end.
Implementing <code>RelmContainerExt</code> for such a type is not possible because it's not clear what the default behavior should be.
Other types such as <code>gtk::Grid</code> even need more information to place children.
In this case, you can simply pass the method name before declaring the child widget.
Also, we often need a reference (<code>&amp;</code>) because most methods in gtk-rs take references.</p>
<pre><code class="language-rust ignore">gtk::HeaderBar {
    pack_start: &amp;gtk::Label {
        // ...
    }
},
gtk::Grid {
    attach[0, 0, 1, 1]: &amp;gtk::Label {
        // ...
    }
}</code></pre>
<h2 id="working-with-gtk-rs"><a class="header" href="#working-with-gtk-rs">Working with gtk-rs</a></h2>
<p>The structure and design of most gtk-rs crates is often a bit different from most other Rust crates.
Because GTK is based on GObject, a C library that implements object-oriented programming, the gtk-rs developers had to come up with some clever ideas to integrate the C code into Rust.</p>
<h3 id="reading-docs"><a class="header" href="#reading-docs">Reading docs</a></h3>
<p>Looking at the documentation of <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/struct.Box.html"><code>gtk::Box</code></a> makes it look like this type has just a <code>new()</code> and a <code>builder()</code> method.
However, this is not quite true as the <code>gtk::Box</code> type comes with plenty of methods.
To find those methods, you have to look at <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/struct.Box.html#implements">"implements" section</a>, which contains a list of traits implemented by this type.
In particular, <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/prelude/trait.BoxExt.html"><code>BoxExt</code></a> gives you a lot of useful methods.
Another very important trait in the list is <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/prelude/trait.WidgetExt.html"><code>WidgetExt</code></a> which is implemented by all widgets.
In the same fashion, you can find the available methods of other widgets.</p>
<h3 id="using-the-inspector"><a class="header" href="#using-the-inspector">Using the inspector</a></h3>
<p>GTK has a built-in inspector that has similar features as browser developer tools.
You can use them to look at individual widgets, modify their properties, apply custom CSS and much more.
In particular, it is very useful for finding the best values before integrating them into your code.</p>
<p>To use the inspector, you only need to press <code>Ctrl+Shift+D</code> while you have a GTK application opened (this not just works for Relm4, but all GTK based apps).
You should see an overview over all your widgets, which you can expand row by row.
Yet, to select widgets, it is more convenient to use the button in the top left which allows you to select a widget by clicking on your app.
Once you have selected a widget, you can modify its properties.</p>
<p>You can also use the CSS tab to apply custom CSS to your application.
Once you entered your rules, make sure the pause button is not selected.
For example, you could try setting a border for every widget:</p>
<pre><code class="language-css">* {
    border: 1px solid red;
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Widget overview</th><th>Widget properties</th></tr></thead><tbody>
<tr><td><img src="img/inspector1.png" alt="Widget overview" /></td><td><img src="img/inspector2.png" alt="Widget properties" /></td></tr>
</tbody></table>
</div>
<h3 id="demo-applications"><a class="header" href="#demo-applications">Demo applications</a></h3>
<p>Both GTK4, libadwaita and ASHPD (a library for portals) have demo applications.
Those are very useful when searching for widgets and other features, especially when combined with the inspector.</p>
<ul>
<li>Setup gnome-nightly flatpak remote: <code>flatpak remote-add --if-not-exists gnome-nightly https://nightly.gnome.org/gnome-nightly.flatpakrepo</code></li>
<li>Install the GTK4 demo: <code>flatpak install gnome-nightly org.gtk.Demo4</code></li>
<li>Install the Adwaita demo: <code>flatpak install gnome-nightly org.gnome.Adwaita1.Demo</code></li>
<li>Install the ASHPD demo: <code>flatpak install flathub com.belmoussaoui.ashpd.demo</code></li>
</ul>
<h2 id="our-ecosystem"><a class="header" href="#our-ecosystem">Our ecosystem</a></h2>
<p>Relm4 also offers a few extra crates and projects to make your life easier:</p>
<ul>
<li><a href="https://github.com/Relm4/relm4-template">relm4-template</a>: A template for flatpak apps that saves a lot of time for setting up new projects</li>
<li><a href="https://github.com/Relm4/icons">relm4-icons</a>: Over 2000 icons, ready to use for your app</li>
<li><a href="https://docs.rs/relm4-components/latest/relm4_components/">relm4-components</a>: A collection of handy components</li>
</ul>
<h2 id="guaranteed-helpful-our-matrix-chat"><a class="header" href="#guaranteed-helpful-our-matrix-chat">Guaranteed helpful: Our matrix chat</a></h2>
<p>In case you didn't find the answer to your question in this book, feel free to ask it in our matrix chat or in a GitHub discussion (you can find all links in our <a href="https://github.com/Relm4/Relm4#readme">README</a>).
We are always happy to help you!
After all, this chapter was assembled from the most common questions we got from either GitHub or the matrix chat.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="efficient-ui-updates"><a class="header" href="#efficient-ui-updates">Efficient UI updates</a></h1>
<p>Relm4 follows the Elm programming model which means that data and widgets are separated. At first glance this might cause a problem. Larger applications need to efficiently update their widgets because rebuilding the whole UI for every update is not an option. But since data and widgets are separated, how do we know which UI elements need to be updated?</p>
<p>Let's have a look at the following example: Imagine you have an app with 1000 counters and you only increment the first counter. The model receives the increment message for the first counter and increments it. Now the view function gets the updated model with 1000 counters and… well, has no idea what has changed! So instead of one UI update we need to do 1000 because we don't know which of our counters was modified.</p>
<p>There are two concepts in Relm4 to avoid unnecessary UI updates:</p>
<ul>
<li><strong>Trackers</strong> identify modifications of fields in <code>struct</code>s to only trigger updates to the affected UI elements.</li>
<li><strong>Factories</strong> track changes in data structures similar to <a href="https://doc.rust-lang.org/std/collections/index.html"><code>std::collections</code></a> in order to perform also minimal UI updates. They are used to generate multiple similar widgets, e.g. a row of buttons, from a data collection.</li>
</ul>
<p>Both concepts are explained in the following chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracker"><a class="header" href="#tracker">Tracker</a></h1>
<p>A tracker in this context simply means a data type that's able to track changes to itself. For example, if we increment the counter of the model we used for our first app, the model might tell us later that the counter changed during the last update function.</p>
<p>Relm4 does not promote any implementation of a tracker. You're free to use any implementation you like, you can even implement a tracker yourself. In this example however, we'll use the <a href="https://docs.rs/tracker/latest/tracker/"><code>tracker</code> crate</a> that provides a simple macro that implements a tracker for us automatically.</p>
<p>Using this technique, we will implement a small program which displays two randomly picked icons controlled by two buttons:</p>
<p><img src="efficient_ui/../img/screenshots/tracker-dark-1.png" alt="App screenshot" /></p>
<p>When pressing a button, the icon above it will change. The background of the application will become green when the two icons are identical:</p>
<p><img src="efficient_ui/../img/screenshots/tracker-dark-2.png" alt="App screenshot with with equal icons" /></p>
<h2 id="the-tracker-crate"><a class="header" href="#the-tracker-crate">The tracker crate</a></h2>
<p>The <a href="https://docs.rs/tracker/latest/tracker/attr.track.html"><code>tracker::track</code></a> macro implements the following methods for your struct fields:</p>
<ul>
<li>
<p><code>get_{field_name}()</code><br />
Get an immutable reference to your field.</p>
</li>
<li>
<p><code>get_mut_{field_name}()</code><br />
Get a mutable reference to your field. Assumes the field will be modified and marks it as changed.</p>
</li>
<li>
<p><code>set_{field_name}(value)</code><br />
Get a mutable reference to your field. Marks the field as changed only if the new value isn't equal with the previous value.</p>
</li>
<li>
<p><code>update_{field_name}(fn)</code><br />
Update your mutable field with a function or a closure. Assumes the field will be modified and marks it as changed.</p>
</li>
</ul>
<p>To check for changes you can call <code>{struct_var_name}.changed(StructName::{field_name}())</code> and it will return a bool indication whether the field was updated.</p>
<p>To reset all previous changes, you can call <code>{struct_var_name}.reset()</code>.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>First we have to add the tracker library to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">tracker = "0.1"
</code></pre>
<p>Now let's have a look at a small example.</p>
<pre><code class="language-rust no_run noplayground">#[tracker::track]
struct Test {
    x: u8,
    y: u64,
}

fn main() {
    let mut t = Test {
        x: 0,
        y: 0,
        // the macro generates a new variable called
        // "tracker" which stores the changes
        tracker: 0,
    };

    t.set_x(42);
    // let's check whether the change was detected
    assert!(t.changed(Test::x()));

    // reset t so we don't track old changes
    t.reset();
 
    t.set_x(42);
    // same value, so no change
    assert!(!t.changed(Test::x()));
}</code></pre>
<p>So in short, the <code>tracker::track</code> macro provides various getters and setters that will mark struct fields as changed. You also get a method that checks for changes and a method to reset the changes.</p>
<h1 id="using-trackers-in-relm4-apps"><a class="header" href="#using-trackers-in-relm4-apps">Using trackers in Relm4 apps</a></h1>
<p>Let's build a simple app that shows two random icons and allows the user to set either of them to a new random icon. As a bonus, we want to show a fancy background color if both icons are the same.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/Relm4/Relm4/blob/main/examples/tracker.rs">here</a>. Run <code>cargo run --example tracker</code> from the <a href="https://github.com/Relm4/Relm4/tree/main/examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="the-icons"><a class="header" href="#the-icons">The icons</a></h2>
<p>Before we can select random icons, we need to quickly implement a function that will return us random image names available in the default GTK icon theme.</p>
<pre><code class="language-rust no_run noplayground">const ICON_LIST: &amp;[&amp;str] = &amp;[
    "bookmark-new-symbolic",
    "edit-copy-symbolic",
    "edit-cut-symbolic",
    "edit-find-symbolic",
    "starred-symbolic",
    "system-run-symbolic",
    "emoji-objects-symbolic",
    "emoji-nature-symbolic",
    "display-brightness-symbolic",
];

fn random_icon_name() -&gt; &amp;'static str {
    ICON_LIST
        .iter()
        .choose(&amp;mut rand::thread_rng())
        .expect("Could not choose a random icon")
}</code></pre>
<h2 id="the-model-1"><a class="header" href="#the-model-1">The model</a></h2>
<p>For our model we only need to store the two icon names and whether both of them are identical.</p>
<pre><code class="language-rust no_run noplayground">#[tracker::track]
struct AppModel {
    first_icon: &amp;'static str,
    second_icon: &amp;'static str,
    identical: bool,
}</code></pre>
<p>The message type is also pretty simple: we just want to update one of the icons.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum AppInput {
    UpdateFirst,
    UpdateSecond,
}</code></pre>
<p>There are a few notable things for the <code>Component</code>'s <code>update</code> implementation.
First, we call <code>self.reset()</code> at the top of the function body. This ensures that the tracker will be reset so we don't track old changes.</p>
<p>Also, we use setters instead of assignments because we want to track these changes. Yet, you could still use the assignment operator if you want to apply changes without notifying the tracker.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;mut self, message: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        // reset tracker value of the model
        self.reset();

        match message {
            AppInput::UpdateFirst =&gt; {
                self.set_first_icon(random_icon_name());
            }
            AppInput::UpdateSecond =&gt; {
                self.set_second_icon(random_icon_name());
            }
        }
        self.set_identical(self.first_icon == self.second_icon);
    }</code></pre>
<h2 id="the-view"><a class="header" href="#the-view">The view</a></h2>
<p>Now we reached the interesting part of the code where we can actually make use of the tracker. Let's have a look at the complete <code>view!</code> macro call:</p>
<pre><code class="language-rust no_run noplayground">    view! {
        #[root]
        gtk::ApplicationWindow {
            #[track = "model.changed(AppModel::identical())"]
            set_class_active: ("identical", model.identical),
            gtk::Box {
                set_orientation: gtk::Orientation::Horizontal,
                set_spacing: 10,
                set_margin_all: 10,
                gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 10,
                    gtk::Image {
                        set_pixel_size: 50,
                        #[track = "model.changed(AppModel::first_icon())"]
                        set_icon_name: Some(model.first_icon),
                    },
                    gtk::Button {
                        set_label: "New random image",
                        connect_clicked[sender] =&gt; move |_| {
                            sender.input(AppInput::UpdateFirst)
                        }
                    }
                },
                append = &amp;gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 10,
                    gtk::Image {
                        set_pixel_size: 50,
                        #[track = "model.changed(AppModel::second_icon())"]
                        set_icon_name: Some(model.second_icon),
                    },
                    gtk::Button {
                        set_label: "New random image",
                        connect_clicked[sender] =&gt; move |_| {
                            sender.input(AppInput::UpdateSecond)
                        }
                    }
                },
            }
        }
    }</code></pre>
<h2 id="the-main-function"><a class="header" href="#the-main-function">The main function</a></h2>
<p>In this example, we need some additional code in <code>fn main()</code> to add <a href="https://docs.gtk.org/gtk4/css-properties.html">custom CSS</a> that sets the background color for elements with class name "identical".
Later, we just need to assign the "identical" class name to a widget to make it match the CSS selector.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    let app = RelmApp::new("relm4.test.simple");
    app.set_global_css(".identical { background: #00ad5c; }");
    app.run::&lt;AppModel&gt;(());
}</code></pre>
<h3 id="the-track-attribute"><a class="header" href="#the-track-attribute">The <code>#[track]</code> attribute</a></h3>
<p>The <code>#[track]</code> attribute is applied to method invocations in our view code. It allows us to add a condition to the update: if the condition is true, the method will be called, otherwise, it will be skipped. The attribute syntax looks like this:</p>
<pre><code class="language-rust no_run noplayground">#[track = "&lt;boolean expression&gt;"]</code></pre>
<p>Let's have a look at its first appearance:</p>
<pre><code class="language-rust no_run noplayground">            #[track = "model.changed(AppModel::identical())"]
            set_class_active: ("identical", model.identical),</code></pre>
<p>The <a href="https://docs.rs/relm4/latest/relm4/trait.RelmWidgetExt.html#tymethod.set_class_active"><code>set_class_active</code></a> method is used to either activate or disable a CSS class. It takes two parameters, the first is the class itself and the second is a boolean which specifies if the class should be added (<code>true</code>) or removed (<code>false</code>).</p>
<p>The value of the <code>#[track]</code> attribute is parsed as a boolean expression. This expression will be used  as a condition to check whether something has changed. If this condition is <code>true</code>, the <code>set_class_active</code> method will be called with the parameters it guards.</p>
<p>The macro expansion for method calls annotated with the <code>#[track]</code> attribute look roughly like this:</p>
<pre><code class="language-rust no_run noplayground">if model.changed(AppModel::identical()) {
    self.main_window.set_class_active("identical", model.identical);
}</code></pre>
<p>That's all. It's pretty simple, actually. We just use a condition that allows us to update our widgets only when needed.</p>
<p>The second <code>#[track]</code> attribute works similarly:</p>
<pre><code class="language-rust no_run noplayground">                        #[track = "model.changed(AppModel::first_icon())"]
                        set_icon_name: Some(model.first_icon),</code></pre>
<blockquote>
<p><strong>Using a tracker as debugging helper</strong></p>
<p>Since the <code>#[track]</code> attribute parses expressions, you can use the following syntax to debug your trackers:</p>
<p><code>#[track = "{ println!("Update widget"); argument }"]</code></p>
</blockquote>
<h2 id="initializing-the-model"><a class="header" href="#initializing-the-model">Initializing the model</a></h2>
<p>There's one last thing to point out. When initializing our model, we need to initialize the <code>tracker</code> field as well. The initial value doesn't really matter because we call <code>reset()</code> in the update function anyway, but usually <code>0</code> is used.</p>
<pre><code class="language-rust no_run noplayground">        let model = AppModel {
            first_icon: random_icon_name(),
            second_icon: random_icon_name(),
            identical: false,
            tracker: 0,
        };</code></pre>
<h2 id="the-complete-code-2"><a class="header" href="#the-complete-code-2">The complete code</a></h2>
<p>Let's look at our code again in one piece to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, OrientableExt};
use rand::prelude::IteratorRandom;
use relm4::{gtk, ComponentParts, ComponentSender, RelmApp, RelmWidgetExt, SimpleComponent};

const ICON_LIST: &amp;[&amp;str] = &amp;[
    "bookmark-new-symbolic",
    "edit-copy-symbolic",
    "edit-cut-symbolic",
    "edit-find-symbolic",
    "starred-symbolic",
    "system-run-symbolic",
    "emoji-objects-symbolic",
    "emoji-nature-symbolic",
    "display-brightness-symbolic",
];

fn random_icon_name() -&gt; &amp;'static str {
    ICON_LIST
        .iter()
        .choose(&amp;mut rand::thread_rng())
        .expect("Could not choose a random icon")
}

// The track proc macro allows to easily track changes to different
// fields of the model
#[tracker::track]
struct AppModel {
    first_icon: &amp;'static str,
    second_icon: &amp;'static str,
    identical: bool,
}

#[derive(Debug)]
enum AppInput {
    UpdateFirst,
    UpdateSecond,
}

#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = ();
    type Input = AppInput;
    type Output = ();

    view! {
        #[root]
        gtk::ApplicationWindow {
            #[track = "model.changed(AppModel::identical())"]
            set_class_active: ("identical", model.identical),
            gtk::Box {
                set_orientation: gtk::Orientation::Horizontal,
                set_spacing: 10,
                set_margin_all: 10,
                gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 10,
                    gtk::Image {
                        set_pixel_size: 50,
                        #[track = "model.changed(AppModel::first_icon())"]
                        set_icon_name: Some(model.first_icon),
                    },
                    gtk::Button {
                        set_label: "New random image",
                        connect_clicked[sender] =&gt; move |_| {
                            sender.input(AppInput::UpdateFirst)
                        }
                    }
                },
                append = &amp;gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 10,
                    gtk::Image {
                        set_pixel_size: 50,
                        #[track = "model.changed(AppModel::second_icon())"]
                        set_icon_name: Some(model.second_icon),
                    },
                    gtk::Button {
                        set_label: "New random image",
                        connect_clicked[sender] =&gt; move |_| {
                            sender.input(AppInput::UpdateSecond)
                        }
                    }
                },
            }
        }
    }

    // Initialize the UI.
    fn init(
        _params: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let model = AppModel {
            first_icon: random_icon_name(),
            second_icon: random_icon_name(),
            identical: false,
            tracker: 0,
        };

        // Insert the macro code generation here
        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, message: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        // reset tracker value of the model
        self.reset();

        match message {
            AppInput::UpdateFirst =&gt; {
                self.set_first_icon(random_icon_name());
            }
            AppInput::UpdateSecond =&gt; {
                self.set_second_icon(random_icon_name());
            }
        }
        self.set_identical(self.first_icon == self.second_icon);
    }
}

fn main() {
    let app = RelmApp::new("relm4.test.simple");
    app.set_global_css(".identical { background: #00ad5c; }");
    app.run::&lt;AppModel&gt;(());
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factory"><a class="header" href="#factory">Factory</a></h1>
<p>Factories define how to generate widgets from data collections.
GTK also has factories, yet Relm4 uses its own factory implementation which is much easier to use in regular Rust code.</p>
<p><img src="efficient_ui/../img/screenshots/factory-dark.png" alt="App screenshot dark" /></p>
<p>This app will have a dynamic number of counters.
Also, the counters can be moved up and down by the user.</p>
<h2 id="factories-in-relm4"><a class="header" href="#factories-in-relm4">Factories in Relm4</a></h2>
<p>Factories allow you to visualize data in a natural way.
If you wanted to store a set of counter values in regular Rust code, you'd probably use <code>Vec&lt;u8&gt;</code>.
However, you can't simply generate widgets from a <code>Vec</code>.</p>
<p>This is where factories are really useful.
Custom collection types like <code>FactoryVecDeque</code> allow you to work with collections of data almost as comfortable as if they were stored in a <code>Vec</code>.
At the same time, factories allow you to automatically visualize the data with widgets.
Additionally, factories are very efficient by reducing the amount of UI updates to a minimum.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/Relm4/Relm4/blob/main/examples/factory.rs">here</a>.
Run <code>cargo run --example factory</code> from the <a href="https://github.com/Relm4/Relm4/tree/main/examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h3 id="the-model-2"><a class="header" href="#the-model-2">The model</a></h3>
<p>First, we define the struct <code>Counter</code> that just stores the value of a single counter.
Later, we will use a <code>FactoryVecDeque</code> to store our counters.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
struct Counter {
    value: u8,
}</code></pre>
<h3 id="the-input-message-type"><a class="header" href="#the-input-message-type">The input message type</a></h3>
<p>Each counter should be able to increment and decrement.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum CounterMsg {
    Increment,
    Decrement,
}</code></pre>
<h3 id="the-output-message-type"><a class="header" href="#the-output-message-type">The output message type</a></h3>
<p>A neat feature of factories is that each element can easily forward their output messages to the input of their parent component.
For example, this is necessary for modifications that require access to the whole <code>FactoryVecDeque</code>, like moving an element to a new position.
Therefore, these actions are covered by the output type.</p>
<p>The actions we want to perform "from outside" are</p>
<ul>
<li>Move a counter up</li>
<li>Move a counter down</li>
<li>Move a counter to the first position</li>
</ul>
<p>Accordingly, our message type looks like this:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum CounterOutput {
    SendFront(DynamicIndex),
    MoveUp(DynamicIndex),
    MoveDown(DynamicIndex),
}</code></pre>
<p>You might wonder why <code>DynamicIndex</code> is used here.
First, the parent component needs to know which element should be moved, which is defined by the index.
Further, elements can move in the <code>FactoryVecDeque</code>.
If we used <code>usize</code> as index instead, it could happen that the index points to another element by the time it is processed.</p>
<h3 id="the-factory-implementation"><a class="header" href="#the-factory-implementation">The factory implementation</a></h3>
<p>Factories use the <code>FactoryComponent</code> trait which is very similar to regular components with some minor adjustments.
For example, <code>FactoryComponent</code> needs the <code>#[relm4::factory]</code> attribute macro and a few more associated types in the trait implementation.</p>
<pre><code class="language-rust no_run noplayground">#[relm4::factory]
impl FactoryComponent for Counter {
    type Init = u8;
    type Input = CounterMsg;
    type Output = CounterOutput;
    type CommandOutput = ();
    type ParentWidget = gtk::Box;</code></pre>
<p>Let's look at the associated types one by one:</p>
<ul>
<li><strong>Init</strong>: The data required to initialize <code>Counter</code>, in this case the initial counter value.</li>
<li><strong>Input</strong>: The input message type.</li>
<li><strong>Output</strong>: The output message type.</li>
<li><strong>CommandOutput</strong>: The command output message type, we don't need it here.</li>
<li><strong>ParentWidget</strong>: The container widget used to store the widgets of the factory, for example <code>gtk::Box</code>.</li>
</ul>
<h3 id="creating-the-widget"><a class="header" href="#creating-the-widget">Creating the widget</a></h3>
<p>The widget creation works as usual with our trusty <code>view</code> macro.
The only difference is that we use <code>self</code> to refer to the model due to differences in the <code>FactoryComponent</code> trait.</p>
<pre><code class="language-rust no_run noplayground">    view! {
        #[root]
        gtk::Box {
            set_orientation: gtk::Orientation::Horizontal,
            set_spacing: 10,

            #[name(label)]
            gtk::Label {
                #[watch]
                set_label: &amp;self.value.to_string(),
                set_width_chars: 3,
            },

            #[name(add_button)]
            gtk::Button {
                set_label: "+",
                connect_clicked =&gt; CounterMsg::Increment,
            },

            #[name(remove_button)]
            gtk::Button {
                set_label: "-",
                connect_clicked =&gt; CounterMsg::Decrement,
            },

            #[name(move_up_button)]
            gtk::Button {
                set_label: "Up",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::MoveUp(index.clone())).unwrap();
                }
            },

            #[name(move_down_button)]
            gtk::Button {
                set_label: "Down",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::MoveDown(index.clone())).unwrap();
                }
            },

            #[name(to_front_button)]
            gtk::Button {
                set_label: "To Start",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::SendFront(index.clone())).unwrap();
                }
            }
        }
    }</code></pre>
<h3 id="initializing-the-model-1"><a class="header" href="#initializing-the-model-1">Initializing the model</a></h3>
<p><code>FactoryComponent</code> has separate functions for initializing the model and the widgets.
This means, that we are a bit less flexible, but don't need <code>view_output!()</code> here.
Also, we just need to implement the <code>init_model</code> function because <code>init_widgets</code> is already implemented by the macro.</p>
<pre><code class="language-rust no_run noplayground">    fn init_model(value: Self::Init, _index: &amp;DynamicIndex, _sender: FactorySender&lt;Self&gt;) -&gt; Self {
        Self { value }
    }</code></pre>
<h2 id="the-main-component"><a class="header" href="#the-main-component">The main component</a></h2>
<p>Now, we have implemented the <code>FactoryComponent</code> type for the elements in our factory.
The only thing left to do is to write our main component to complete our app.</p>
<h3 id="the-component-types"><a class="header" href="#the-component-types">The component types</a></h3>
<p>For the main component we implement the familiar <code>SimpleComponent</code> trait.
First we define the model and the input message type and then start the trait implementation.</p>
<pre><code class="language-rust no_run noplayground">struct App {
    created_widgets: u8,
    counters: FactoryVecDeque&lt;Counter&gt;,
}

#[derive(Debug)]
enum AppMsg {
    AddCounter,
    RemoveCounter,
    SendFront(DynamicIndex),
    MoveUp(DynamicIndex),
    MoveDown(DynamicIndex),
}

#[relm4::component]
impl SimpleComponent for App {
    type Init = u8;
    type Input = AppMsg;
    type Output = ();</code></pre>
<h3 id="initializing-the-factory"><a class="header" href="#initializing-the-factory">Initializing the factory</a></h3>
<p>We skip the <code>view</code> macro for a moment and look at the <code>init</code> method.
You see that we are initializing the <code>FactoryVecDeque</code> using a builder pattern.
First, we call <code>FactoryVecDeque::builder()</code> to create the builder and use <code>launch()</code> to set the root widget of the factory.
This widget will store all the widgets created by the factory.</p>
<p>Then, we use the <code>forward()</code> method to pass all output messages of our factory (with type <code>CounterOutput</code>)  to the input of our component (with type <code>AppMsg</code>).</p>
<p>The last trick we have up our sleeves is to define a local variable <code>counter_box</code> that is a reference to the container widget of our factory.
We'll use it in the <code>view</code> macro in the next section.</p>
<pre><code class="language-rust no_run noplayground">    // Initialize the UI.
    fn init(
        counter: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let counters = FactoryVecDeque::builder()
            .launch(gtk::Box::default())
            .forward(sender.input_sender(), |output| match output {
                CounterOutput::SendFront(index) =&gt; AppMsg::SendFront(index),
                CounterOutput::MoveUp(index) =&gt; AppMsg::MoveUp(index),
                CounterOutput::MoveDown(index) =&gt; AppMsg::MoveDown(index),
            });

        let model = App {
            created_widgets: counter,
            counters,
        };

        let counter_box = model.counters.widget();
        let widgets = view_output!();

        ComponentParts { model, widgets }
    }</code></pre>
<h3 id="initializing-the-widgets"><a class="header" href="#initializing-the-widgets">Initializing the widgets</a></h3>
<p>The familiar <code>view</code> macro comes into play again.
Most things should look familiar, but this time we use a <code>#[local_ref]</code> attribute for the last widget to use the local variable we defined in the previous section.
This trick allows us to initialize the model with its <code>FactoryVecDeque</code> before the widgets, which is more convenient in most cases.</p>
<pre><code class="language-rust no_run noplayground">    view! {
        gtk::Window {
            set_title: Some("Factory example"),
            set_default_size: (300, 100),

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,
                set_spacing: 5,
                set_margin_all: 5,

                gtk::Button {
                    set_label: "Add counter",
                    connect_clicked =&gt; AppMsg::AddCounter,
                },

                gtk::Button {
                    set_label: "Remove counter",
                    connect_clicked =&gt; AppMsg::RemoveCounter,
                },

                #[local_ref]
                counter_box -&gt; gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 5,
                }
            }
        }
    }</code></pre>
<h3 id="the-main-update-function"><a class="header" href="#the-main-update-function">The main update function</a></h3>
<p>This time the main update function has actually quite a bit to do.
The code should be quite readable if you worked with <code>Vec</code> or <code>VecDeque</code> before.</p>
<p>One thing stands out though: We see a lot of calls to <code>guard()</code>.
In fact, all mutating methods of <code>FactoryVecDeque</code> need an RAII-guard.
This is similar to a <code>MutexGuard</code> you get from locking a mutex.</p>
<p>The reason for this is simple.
As long as the guard is alive, we can perform multiple operations.
Once we're done, we just drop the guard (or rather leave the current scope) and this will cause the factory to update its widgets automatically.
The neat thing: You can never forget to render changes, and the update algorithm can optimize widget updates for efficiency.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::AddCounter =&gt; {
                self.counters.guard().push_back(self.created_widgets);
                self.created_widgets = self.created_widgets.wrapping_add(1);
            }
            AppMsg::RemoveCounter =&gt; {
                self.counters.guard().pop_back();
            }
            AppMsg::SendFront(index) =&gt; {
                self.counters.guard().move_front(index.current_index());
            }
            AppMsg::MoveDown(index) =&gt; {
                let index = index.current_index();
                let new_index = index + 1;
                // Already at the end?
                if new_index &lt; self.counters.len() {
                    self.counters.guard().move_to(index, new_index);
                }
            }
            AppMsg::MoveUp(index) =&gt; {
                let index = index.current_index();
                // Already at the start?
                if index != 0 {
                    self.counters.guard().move_to(index, index - 1);
                }
            }
        }
    }</code></pre>
<h3 id="the-main-function-1"><a class="header" href="#the-main-function-1">The main function</a></h3>
<p>Awesome, we almost made it!</p>
<p>We only need to define the main function to run our application.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    let app = RelmApp::new("relm4.example.factory");
    app.run::&lt;App&gt;(0);
}</code></pre>
<h2 id="the-complete-code-3"><a class="header" href="#the-complete-code-3">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt, OrientableExt};
use relm4::factory::{DynamicIndex, FactoryComponent, FactorySender, FactoryVecDeque};
use relm4::{gtk, ComponentParts, ComponentSender, RelmApp, RelmWidgetExt, SimpleComponent};

#[derive(Debug)]
struct Counter {
    value: u8,
}

#[derive(Debug)]
enum CounterMsg {
    Increment,
    Decrement,
}

#[derive(Debug)]
enum CounterOutput {
    SendFront(DynamicIndex),
    MoveUp(DynamicIndex),
    MoveDown(DynamicIndex),
}

#[relm4::factory]
impl FactoryComponent for Counter {
    type Init = u8;
    type Input = CounterMsg;
    type Output = CounterOutput;
    type CommandOutput = ();
    type ParentWidget = gtk::Box;

    view! {
        #[root]
        gtk::Box {
            set_orientation: gtk::Orientation::Horizontal,
            set_spacing: 10,

            #[name(label)]
            gtk::Label {
                #[watch]
                set_label: &amp;self.value.to_string(),
                set_width_chars: 3,
            },

            #[name(add_button)]
            gtk::Button {
                set_label: "+",
                connect_clicked =&gt; CounterMsg::Increment,
            },

            #[name(remove_button)]
            gtk::Button {
                set_label: "-",
                connect_clicked =&gt; CounterMsg::Decrement,
            },

            #[name(move_up_button)]
            gtk::Button {
                set_label: "Up",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::MoveUp(index.clone())).unwrap();
                }
            },

            #[name(move_down_button)]
            gtk::Button {
                set_label: "Down",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::MoveDown(index.clone())).unwrap();
                }
            },

            #[name(to_front_button)]
            gtk::Button {
                set_label: "To Start",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::SendFront(index.clone())).unwrap();
                }
            }
        }
    }

    fn init_model(value: Self::Init, _index: &amp;DynamicIndex, _sender: FactorySender&lt;Self&gt;) -&gt; Self {
        Self { value }
    }

    fn update(&amp;mut self, msg: Self::Input, _sender: FactorySender&lt;Self&gt;) {
        match msg {
            CounterMsg::Increment =&gt; {
                self.value = self.value.wrapping_add(1);
            }
            CounterMsg::Decrement =&gt; {
                self.value = self.value.wrapping_sub(1);
            }
        }
    }
}

struct App {
    created_widgets: u8,
    counters: FactoryVecDeque&lt;Counter&gt;,
}

#[derive(Debug)]
enum AppMsg {
    AddCounter,
    RemoveCounter,
    SendFront(DynamicIndex),
    MoveUp(DynamicIndex),
    MoveDown(DynamicIndex),
}

#[relm4::component]
impl SimpleComponent for App {
    type Init = u8;
    type Input = AppMsg;
    type Output = ();

    view! {
        gtk::Window {
            set_title: Some("Factory example"),
            set_default_size: (300, 100),

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,
                set_spacing: 5,
                set_margin_all: 5,

                gtk::Button {
                    set_label: "Add counter",
                    connect_clicked =&gt; AppMsg::AddCounter,
                },

                gtk::Button {
                    set_label: "Remove counter",
                    connect_clicked =&gt; AppMsg::RemoveCounter,
                },

                #[local_ref]
                counter_box -&gt; gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 5,
                }
            }
        }
    }

    // Initialize the UI.
    fn init(
        counter: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let counters = FactoryVecDeque::builder()
            .launch(gtk::Box::default())
            .forward(sender.input_sender(), |output| match output {
                CounterOutput::SendFront(index) =&gt; AppMsg::SendFront(index),
                CounterOutput::MoveUp(index) =&gt; AppMsg::MoveUp(index),
                CounterOutput::MoveDown(index) =&gt; AppMsg::MoveDown(index),
            });

        let model = App {
            created_widgets: counter,
            counters,
        };

        let counter_box = model.counters.widget();
        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::AddCounter =&gt; {
                self.counters.guard().push_back(self.created_widgets);
                self.created_widgets = self.created_widgets.wrapping_add(1);
            }
            AppMsg::RemoveCounter =&gt; {
                self.counters.guard().pop_back();
            }
            AppMsg::SendFront(index) =&gt; {
                self.counters.guard().move_front(index.current_index());
            }
            AppMsg::MoveDown(index) =&gt; {
                let index = index.current_index();
                let new_index = index + 1;
                // Already at the end?
                if new_index &lt; self.counters.len() {
                    self.counters.guard().move_to(index, new_index);
                }
            }
            AppMsg::MoveUp(index) =&gt; {
                let index = index.current_index();
                // Already at the start?
                if index != 0 {
                    self.counters.guard().move_to(index, index - 1);
                }
            }
        }
    }
}

fn main() {
    let app = RelmApp::new("relm4.example.factory");
    app.run::&lt;App&gt;(0);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-position-function"><a class="header" href="#the-position-function">The position function</a></h1>
<p>Most widgets such as <code>gtk::Box</code> don't use the position function because they are one-dimensional and place widgets relative to each other. However, a few widgets such as <code>gtk::Grid</code> use fixed positions and need the position function to work inside a factory.</p>
<p>The task of the position function is mainly to map the index to a certain position/area (x, y, width and height) of a factory widget within the parent widget (view).</p>
<blockquote>
<p>The code we will use in this chapter is based on the grid_factory example <a href="https://github.com/Relm4/Relm4/blob/main/examples/grid_factory.rs">here</a>. Run <code>cargo run --example grid_factory</code> from the <a href="https://github.com/Relm4/Relm4/tree/main/examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>Let's take a grid as an example. For a grid, there are many possibilities to place your widgets. You can, for example, place three, four or five widgets per row or you could place a certain amount of widgets per column. You can even create patterns like a chess grid if you want to.</p>
<p>However, we want to use a factory for generating our widgets, which means we only have the index to calculate the desired two-dimensional position. In the simplest case, we create a layout that places a certain amount of widgets per row or per column.</p>
<p><img src="efficient_ui/../img/grid_layout.svg" alt="Grid layout example" /></p>
<p>To place three elements per row from left to right in a <code>gtk::Grid</code> we could use the following position function.</p>
<pre><code class="language-rust no_run noplayground">    fn position(&amp;self, index: &amp;usize) -&gt; GridPosition {
        let index = *index as i32;

        let row = index / 3;
        let column = index % 3;

        GridPosition {
            column,
            row,
            width: 1,
            height: 1,
        }
    }</code></pre>
<p>And indeed, it works as expected.</p>
<p><img src="efficient_ui/../img/row_grid_screenshot.png" alt="Row placement grid screenshot" /></p>
<h2 id="a-chess-grid"><a class="header" href="#a-chess-grid">A chess grid</a></h2>
<p>Let's have a look at a more complex layout. It's unlikely that this would be used in a real application, but it's still interesting to have a look at it.</p>
<p>To create a chess grid layout, we need to place our widgets only on fields of one color and leave the other fields empty.</p>
<p><img src="efficient_ui/../img/chess_layout.svg" alt="Grid layout example" /></p>
<p>Actually, the code isn't too complicated.</p>
<pre><code class="language-rust no_run noplayground">    fn position(&amp;self, index: &amp;usize) -&gt; GridPosition {
        let index = *index as i32;

        // add a new row for every 5 elements
        let row = index / 5;
        // use every second column and move columns in uneven rows by 1
        let column = (index % 5) * 2 + row % 2;

        GridPosition {
            column,
            row,
            width: 1,
            height: 1,
        }
    }</code></pre>
<p>And as you can see, it works!</p>
<p><img src="efficient_ui/../img/chess_grid_screenshot.png" alt="Chess grid layout screenshot" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components-1"><a class="header" href="#components-1">Components</a></h1>
<p>Technically, we already used components in the previous chapters.
So far, we've only used one component per application, but in this chapter, we're going to use multiple components to structure our app.</p>
<p>Components are independent parts of your application that can communicate with each other.
They are used in a parent-child model: The main app component can have several components and each component can have child components and so on.
This means that each component has a parent, except for the main app component which is at the top of this tree structure.</p>
<p>To showcase this, we will create a small application which opens a dialog when the user tries to close it.
The header bar and the dialog will be implemented as standalone components.</p>
<p><img src="img/screenshots/components-dark-1.png" alt="App screenshot dark" /></p>
<p><img src="img/screenshots/components-dark-2.png" alt="App screenshot dark" /></p>
<h2 id="when-to-use-components"><a class="header" href="#when-to-use-components">When to use components</a></h2>
<p>Components are very useful for separating parts of the UI into smaller, more manageable parts.
They are not necessary but for larger applications, they can be very helpful.</p>
<h2 id="message-handling"><a class="header" href="#message-handling">Message handling</a></h2>
<p>Components store their child components inside the model as a <code>Controller&lt;ChildModel&gt;</code> and handle output messages in the <code>init</code> function by calling the <code>forward</code> method.</p>
<pre><code class="language-rust no_run noplayground">        let header: Controller&lt;HeaderModel&gt; =
            HeaderModel::builder()
                .launch(())
                .forward(sender.input_sender(), |msg| match msg {
                    HeaderOutput::View =&gt; AppMsg::SetMode(AppMode::View),
                    HeaderOutput::Edit =&gt; AppMsg::SetMode(AppMode::Edit),
                    HeaderOutput::Export =&gt; AppMsg::SetMode(AppMode::Export),
                });</code></pre>
<p>The <code>forward</code> method will redirect the output messages from the child component and transform them into the parent's input messages.</p>
<blockquote>
<p>Components are independent from each another so a component can be used easily with several different parent components.
Therefore, the child component doesn't know which type its parent component will have.
Thus, the <code>forward</code> method allows the parent component to transform the output messages of child components to a message type it can handle properly.</p>
<p>In this example, <code>HeaderOutput</code> messages are translated into <code>AppMsg</code>.</p>
</blockquote>
<h1 id="example-application"><a class="header" href="#example-application">Example application</a></h1>
<p>Let's write a small example app to see how components can be used in action. For this example, we write parts of an app that can edit images.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/Relm4/Relm4/blob/main/examples/components.rs">here</a>. Run <code>cargo run --example components</code> from the <a href="https://github.com/Relm4/Relm4/tree/main/examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="the-header-bar"><a class="header" href="#the-header-bar">The header bar</a></h2>
<p>Our first component will be a header bar. There are not a lot of advantages for writing this as component except for reducing the complexity in other parts of our UI.</p>
<p>The header bar will have three buttons for three modes that our application can have:</p>
<ul>
<li><strong>View</strong>: View the image.</li>
<li><strong>Edit</strong>: Edit the image.</li>
<li><strong>Export</strong>: Export the image in different formats.</li>
</ul>
<p>We will not implement the actual functionality, but instead use placeholders to keep things simple.</p>
<h3 id="the-model-3"><a class="header" href="#the-model-3">The model</a></h3>
<p>Usually you want to store everything that affects only your component in the state of the component. However, in this case, there is no state that can be stored in the component, but only state that affects the root component (app). Therefore, we leave the model empty and only send messages to the root component.</p>
<pre><code class="language-rust no_run noplayground">struct HeaderModel;</code></pre>
<p>The message type allows us to switch between the modes.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum HeaderOutput {
    View,
    Edit,
    Export,
}</code></pre>
<p>Our component needs no <code>update</code> method, because the <code>view</code> can emit the component's output messages as part of its click signal handlers, as we will see in the next section.</p>
<h3 id="the-widgets-1"><a class="header" href="#the-widgets-1">The widgets</a></h3>
<p>There's nothing special about widgets of a child component. The only difference to the main app component is that the root widget doesn't need to be a <code>gtk::Window</code>. Instead, we use a <code>gtk::HeaderBar</code> here, but theoretically the root widget doesn't even need to be a widget at all (which can be useful in special cases).</p>
<pre><code class="language-rust no_run noplayground">    view! {
        #[root]
        gtk::HeaderBar {
            #[wrap(Some)]
            set_title_widget = &amp;gtk::Box {
                add_css_class: "linked",
                #[name = "group"]
                gtk::ToggleButton {
                    set_label: "View",
                    set_active: true,
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::View).unwrap()
                        }
                    },
                },
                gtk::ToggleButton {
                    set_label: "Edit",
                    set_group: Some(&amp;group),
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::Edit).unwrap()
                        }
                    },
                },
                gtk::ToggleButton {
                    set_label: "Export",
                    set_group: Some(&amp;group),
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::Export).unwrap()
                        }
                    },
                },
            }
        }
    }</code></pre>
<h2 id="the-close-alert"><a class="header" href="#the-close-alert">The close alert</a></h2>
<p>As with a normal application used to edit files, we want to notify the user before they accidentally close the application and discard all progress. For this — you might have guessed it already — we will use another component.</p>
<h3 id="the-model-4"><a class="header" href="#the-model-4">The model</a></h3>
<p>The state of the dialog only needs to store whether or not it's hidden.</p>
<pre><code class="language-rust no_run noplayground">struct DialogModel {
    hidden: bool,
}</code></pre>
<p>The message contains three options:</p>
<ul>
<li><strong>Show</strong> is used by the parent to display the dialog.</li>
<li><strong>Accept</strong> is used internally to indicate that the user agreed to close the application.</li>
<li><strong>Cancel</strong> is used internally to indicate that the user changes his mind and doesn't want to close the application.</li>
</ul>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum DialogInput {
    Show,
    Accept,
    Cancel,
}

#[derive(Debug)]
enum DialogOutput {
    Close,
}</code></pre>
<h3 id="the-widgets-2"><a class="header" href="#the-widgets-2">The widgets</a></h3>
<p>Unlike the last component, the <code>DialogModel</code> component doesn't send its output messages from a signal handler. Instead, the <code>response</code> signal handler sends <em>input</em> messages to itself, handles them in <code>update</code>, and then sends output messages if necessary. This is a common pattern for more complex components.</p>
<blockquote>
<p>If your component accepts non-internal inputs as well, you may want to mark the internal variants as <code>#[doc(hidden)]</code> so that users of your component know they're only intended for internal use.</p>
</blockquote>
<pre><code class="language-rust no_run noplayground">    view! {
        gtk::MessageDialog {
            set_modal: true,
            #[watch]
            set_visible: !model.hidden,
            set_text: Some("Do you want to close before saving?"),
            set_secondary_text: Some("All unsaved changes will be lost"),
            add_button: ("Close", gtk::ResponseType::Accept),
            add_button: ("Cancel", gtk::ResponseType::Cancel),
            connect_response[sender] =&gt; move |_, resp| {
                sender.input(if resp == gtk::ResponseType::Accept {
                    DialogInput::Accept
                } else {
                    DialogInput::Cancel
                })
            }
        }
    }</code></pre>
<p>In the <code>update</code> implementation, we match the input messages and emit an output if needed.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;mut self, msg: Self::Input, sender: ComponentSender&lt;Self&gt;) {
        match msg {
            DialogInput::Show =&gt; self.hidden = false,
            DialogInput::Accept =&gt; {
                self.hidden = true;
                sender.output(DialogOutput::Close).unwrap()
            }
            DialogInput::Cancel =&gt; self.hidden = true,
        }
    }</code></pre>
<h2 id="the-main-app"><a class="header" href="#the-main-app">The main app</a></h2>
<p>Now all parts come together to form a single app.</p>
<h3 id="the-model-5"><a class="header" href="#the-model-5">The model</a></h3>
<p>First, let's define the model of the main app and its messages.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum AppMode {
    View,
    Edit,
    Export,
}

#[derive(Debug)]
enum AppMsg {
    SetMode(AppMode),
    CloseRequest,
    Close,
}

struct AppModel {
    mode: AppMode,
    header: Controller&lt;HeaderModel&gt;,
    dialog: Controller&lt;DialogModel&gt;,
}</code></pre>
<p>The <code>AppMode</code> struct stores the modes the application can be in. The <code>SetMode</code> message is transformed from the output of our header bar component to update the state of the main application when someone presses a button in the header bar. The <code>Close</code> message is transformed from the output of the dialog component to indicate that the window should be closed.</p>
<p>In the model, we store the current <code>AppMode</code> as well as a <code>Controller</code> for each of our child components.</p>
<p>The update function of the model is pretty straightforward.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::SetMode(mode) =&gt; {
                self.mode = mode;
            }
            AppMsg::CloseRequest =&gt; {
                self.dialog.sender().send(DialogInput::Show).unwrap();
            }
            AppMsg::Close =&gt; {
                relm4::main_application().quit();
            }
        }
    }</code></pre>
<p>We can retrieve a sender for the child component by calling the <code>sender()</code> method on the associated <code>Controller</code>, and then send messages of the associated <code>Input</code> type through it.</p>
<h3 id="controllers"><a class="header" href="#controllers">Controllers</a></h3>
<p>When initializing the app component, we construct the child components by passing the appropriate <code>Init</code> and forwarding any desired inputs and outputs. This is done through a builder provided by <code>Component</code> implementations. We pass the initial parameters via the <code>launch</code> method, and then retrieve the final <code>Controller</code> by calling the <code>forward</code> method. In addition to starting the component, the <code>forward</code> method allows us to take the outputs of the component, transform them with a mapping function, and then pass the result as an input message to another sender (in this case, the input sender of the app component). If you don't need to forward any outputs, you can start the component with the <code>detach</code> method instead.</p>
<pre><code class="language-rust no_run noplayground">    fn init(
        params: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let header: Controller&lt;HeaderModel&gt; =
            HeaderModel::builder()
                .launch(())
                .forward(sender.input_sender(), |msg| match msg {
                    HeaderOutput::View =&gt; AppMsg::SetMode(AppMode::View),
                    HeaderOutput::Edit =&gt; AppMsg::SetMode(AppMode::Edit),
                    HeaderOutput::Export =&gt; AppMsg::SetMode(AppMode::Export),
                });

        let dialog = DialogModel::builder()
            .transient_for(&amp;root)
            .launch(true)
            .forward(sender.input_sender(), |msg| match msg {
                DialogOutput::Close =&gt; AppMsg::Close,
            });

        let model = AppModel {
            mode: params,
            header,
            dialog,
        };

        let widgets = view_output!();
        ComponentParts { model, widgets }
    }</code></pre>
<p>Also, we set the <code>set_transient_for</code> property, which actually uses the main window. The dialog should set his parent window so that GTK can handle the dialog better. The GTK docs state: "[set_transient_for] allows window managers to e.g. keep the dialog on top of the main window, or center the dialog over the main window".</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum AppMode {
    View,
    Edit,
    Export,
}

#[derive(Debug)]
enum AppMsg {
    SetMode(AppMode),
    CloseRequest,
    Close,
}

struct AppModel {
    mode: AppMode,
    header: Controller&lt;HeaderModel&gt;,
    dialog: Controller&lt;DialogModel&gt;,
}</code></pre>
<h3 id="the-widgets-3"><a class="header" href="#the-widgets-3">The widgets</a></h3>
<p>We're almost done! Lastly, let's take a look at the app widgets.</p>
<pre><code class="language-rust no_run noplayground">    view! {
        main_window = gtk::Window {
            set_default_width: 500,
            set_default_height: 250,
            set_titlebar: Some(model.header.widget()),

            gtk::Label {
                #[watch]
                set_label: &amp;format!("Placeholder for {:?}", model.mode),
            },
            connect_close_request[sender] =&gt; move |_| {
                sender.input(AppMsg::CloseRequest);
                gtk::glib::Propagation::Stop
            }
        }
    }</code></pre>
<p>Most notably, we retrieve the root widget of our header component through the <code>widget()</code> method on the associated <code>Controller</code> to set it as a child of the main window.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>You now know most of the secrets that Relm4 offers. Components can be powerful and if they are implemented correctly, they are even reusable across different apps. The relm4-components crate offers several reusable components you can use in your applications. In the following chapters, we'll look at an even simpler component type called worker, how to implement reusable components yourself and how to use components with async code and multiple threads.</p>
<h2 id="the-complete-code-4"><a class="header" href="#the-complete-code-4">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{
    ApplicationExt, ButtonExt, DialogExt, GtkWindowExt, ToggleButtonExt, WidgetExt,
};
use relm4::*;

struct HeaderModel;

#[derive(Debug)]
enum HeaderOutput {
    View,
    Edit,
    Export,
}


#[relm4::component]
impl SimpleComponent for HeaderModel {
    type Init = ();
    type Input = ();
    type Output = HeaderOutput;

    view! {
        #[root]
        gtk::HeaderBar {
            #[wrap(Some)]
            set_title_widget = &amp;gtk::Box {
                add_css_class: "linked",
                #[name = "group"]
                gtk::ToggleButton {
                    set_label: "View",
                    set_active: true,
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::View).unwrap()
                        }
                    },
                },
                gtk::ToggleButton {
                    set_label: "Edit",
                    set_group: Some(&amp;group),
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::Edit).unwrap()
                        }
                    },
                },
                gtk::ToggleButton {
                    set_label: "Export",
                    set_group: Some(&amp;group),
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::Export).unwrap()
                        }
                    },
                },
            }
        }
    }

    fn init(
        _params: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let model = HeaderModel;
        let widgets = view_output!();
        ComponentParts { model, widgets }
    }
}


struct DialogModel {
    hidden: bool,
}

#[derive(Debug)]
enum DialogInput {
    Show,
    Accept,
    Cancel,
}

#[derive(Debug)]
enum DialogOutput {
    Close,
}

#[relm4::component]
impl SimpleComponent for DialogModel {
    type Init = bool;
    type Input = DialogInput;
    type Output = DialogOutput;

    view! {
        gtk::MessageDialog {
            set_modal: true,
            #[watch]
            set_visible: !model.hidden,
            set_text: Some("Do you want to close before saving?"),
            set_secondary_text: Some("All unsaved changes will be lost"),
            add_button: ("Close", gtk::ResponseType::Accept),
            add_button: ("Cancel", gtk::ResponseType::Cancel),
            connect_response[sender] =&gt; move |_, resp| {
                sender.input(if resp == gtk::ResponseType::Accept {
                    DialogInput::Accept
                } else {
                    DialogInput::Cancel
                })
            }
        }
    }

    fn init(
        params: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let model = DialogModel { hidden: params };
        let widgets = view_output!();
        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, msg: Self::Input, sender: ComponentSender&lt;Self&gt;) {
        match msg {
            DialogInput::Show =&gt; self.hidden = false,
            DialogInput::Accept =&gt; {
                self.hidden = true;
                sender.output(DialogOutput::Close).unwrap()
            }
            DialogInput::Cancel =&gt; self.hidden = true,
        }
    }
}

#[derive(Debug)]
enum AppMode {
    View,
    Edit,
    Export,
}

#[derive(Debug)]
enum AppMsg {
    SetMode(AppMode),
    CloseRequest,
    Close,
}

struct AppModel {
    mode: AppMode,
    header: Controller&lt;HeaderModel&gt;,
    dialog: Controller&lt;DialogModel&gt;,
}

#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = AppMode;
    type Input = AppMsg;
    type Output = ();

    view! {
        main_window = gtk::Window {
            set_default_width: 500,
            set_default_height: 250,
            set_titlebar: Some(model.header.widget()),

            gtk::Label {
                #[watch]
                set_label: &amp;format!("Placeholder for {:?}", model.mode),
            },
            connect_close_request[sender] =&gt; move |_| {
                sender.input(AppMsg::CloseRequest);
                gtk::glib::Propagation::Stop
            }
        }
    }

    fn init(
        params: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let header: Controller&lt;HeaderModel&gt; =
            HeaderModel::builder()
                .launch(())
                .forward(sender.input_sender(), |msg| match msg {
                    HeaderOutput::View =&gt; AppMsg::SetMode(AppMode::View),
                    HeaderOutput::Edit =&gt; AppMsg::SetMode(AppMode::Edit),
                    HeaderOutput::Export =&gt; AppMsg::SetMode(AppMode::Export),
                });

        let dialog = DialogModel::builder()
            .transient_for(&amp;root)
            .launch(true)
            .forward(sender.input_sender(), |msg| match msg {
                DialogOutput::Close =&gt; AppMsg::Close,
            });

        let model = AppModel {
            mode: params,
            header,
            dialog,
        };

        let widgets = view_output!();
        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::SetMode(mode) =&gt; {
                self.mode = mode;
            }
            AppMsg::CloseRequest =&gt; {
                self.dialog.sender().send(DialogInput::Show).unwrap();
            }
            AppMsg::Close =&gt; {
                relm4::main_application().quit();
            }
        }
    }
}

fn main() {
    let relm = RelmApp::new("ewlm4.test.components");
    relm.run::&lt;AppModel&gt;(AppMode::Edit);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Most user inputs are fairly easy to process.
After receiving a message, you process it in the update function and update the view.
Everything only takes a couple of milliseconds at most, so the user won't even notice the slight delay.</p>
<p>However, when you have to perform complex calculations or I/O-bound operations that take more than a couple of milliseconds to complete, the user will start noticing that the app doesn't feel reactive or "snappy" anymore.
For example, such operations are performing network requests, filesystems operations or calculating the last digit of π.</p>
<p>To better visualize what happens, let's look at the following image.
The expected behavior is on the left, where processing of updates is fast and the app spends most of the time idle, waiting for new user inputs (aka events).
Yet on the right, the update function is very slow and blocks the entire application so that no other events can be processed in the meantime and the view update is delayed.</p>
<img src="threads_and_async/../img/blocking_update_timing.png" style="width: 90%"/>
<p>The behavior on the right will freeze the entire application and should be avoided.
Fortunately, Relm4 gives you plenty of options to keep your application responsive.</p>
<h2 id="understanding-the-problem"><a class="header" href="#understanding-the-problem">Understanding the problem</a></h2>
<p>In general, we can divide the problem into two categories:</p>
<ul>
<li><strong>CPU-bound</strong> operations take a lot of time because actual work needs to be done by the CPU.</li>
<li><strong>I/O-bound</strong> operations take a lot of time because we have to wait for something to happen, for example, a response from a server.
This means that we have CPU resources to do other things in the meantime, but to use them, we need a mechanism like async/await.</li>
</ul>
<h3 id="cpu-bound-and-other-synchronous-operations"><a class="header" href="#cpu-bound-and-other-synchronous-operations">CPU-bound and other synchronous operations</a></h3>
<p>Let's look at an example of a CPU-bound operation.
For an app that generates cryptographic keys, you might define a <code>generate_rsa_key()</code> function.
This function takes some time to compute because generating the key is a difficult calculation so we can treat it as if it was implemented like this:</p>
<pre><code class="language-rust no_run noplayground">fn generate_rsa_key() {
    std::thread::sleep(Duration::from_secs(10));
}</code></pre>
<p>If our component receives a <code>GenerateKey</code> message, we start generating the key.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::GenerateKey =&gt; {
                self.rsa_key = generate_rsa_key();
            }
        }
    }</code></pre>
<p>Unfortunately, this will freeze our app.
There's no trick to avoid this, the CPU must do a lot of work to calculate the result.
However, we can offload this work to other threads to keep our application responsive.</p>
<p>Possible solutions for this problem are:</p>
<ul>
<li><strong>Workers</strong>: A component without widgets that runs on its own thread</li>
<li><strong>Commands</strong>: Offload tasks to a runtime in the background and receive a message when the task completes</li>
</ul>
<p>Both are covered in the following chapters.</p>
<h3 id="io-bound-and-other-async-operations"><a class="header" href="#io-bound-and-other-async-operations">I/O-bound and other async operations</a></h3>
<p>Let's say we also need to perform a web-request to fetch existing encryption keys from a server.
In theory, we could use a blocking HTTP client which would put us in the same situation as before.
However, using async/await allows us to use the CPU for other things while we're waiting for the response.
The resulting asynchronous function could look like this.</p>
<pre><code class="language-rust no_run noplayground">async fn fetch_rsa_key() {
    tokio::time::sleep(Duration::from_secs(10)).await;
}</code></pre>
<p>Since we now have an asynchronous function, we can't simply call it like a regular function.
Again, there are two options to make this work:</p>
<ul>
<li><strong>Async components and factories</strong>: Asynchronous traits for components and factories</li>
<li><strong>Commands</strong>: Offload tasks to a runtime in the background and receive a message when the task completes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workers"><a class="header" href="#workers">Workers</a></h1>
<p>Workers are simply components that don't have any widgets.
They can be quite useful for applications that need to handle long tasks while remaining responsive.
In particular, they are suitable for CPU-bound tasks which need to be handled <strong>one at the time</strong> because they run on a different thread.</p>
<h2 id="implementing-a-worker"><a class="header" href="#implementing-a-worker">Implementing a worker</a></h2>
<p>A worker is implemented similarly to a component by using the <code>Worker</code> trait.
Since workers don't have widgets, you don't need to provide a <code>Widgets</code> type.</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
enum AppMsg {
    Increment,
    Decrement,
}

#[derive(Debug)]
enum AsyncHandlerMsg {
    DelayedIncrement,
    DelayedDecrement,
}

struct AsyncHandler;

impl Worker for AsyncHandler {
    type Init = ();
    type Input = AsyncHandlerMsg;
    type Output = AppMsg;

    fn init(_init: Self::Init, _sender: ComponentSender&lt;Self&gt;) -&gt; Self {
        Self
    }

    fn update(&amp;mut self, msg: AsyncHandlerMsg, sender: ComponentSender&lt;Self&gt;) {
        // Simulating heavy CPU-bound task
        std::thread::sleep(Duration::from_secs(1));

        // Send the result of the calculation back
        match msg {
            AsyncHandlerMsg::DelayedIncrement =&gt; sender.output(AppMsg::Increment),
            AsyncHandlerMsg::DelayedDecrement =&gt; sender.output(AppMsg::Decrement),
        }
        .unwrap()
    }
}</code></pre>
<p>Workers are constructed similarly to components, too.
Use the provided builder to retrieve a <code>WorkerController</code>.</p>
<pre><code class="language-rust ignore">    fn init(_: (), root: Self::Root, sender: ComponentSender&lt;Self&gt;) -&gt; ComponentParts&lt;Self&gt; {
        let model = AppModel {
            counter: 0,
            worker: AsyncHandler::builder()
                .detach_worker(())
                .forward(sender.input_sender(), identity),
        };

        let widgets = view_output!();

        ComponentParts { model, widgets }
    }</code></pre>
<p>Through the <code>WorkerController</code>, you can send and receive messages from the worker.
The worker's <code>update</code> function will run on a separate thread, so your other components won't be blocked.</p>
<pre><code class="language-rust ignore">struct AppModel {
    counter: u8,
    worker: WorkerController&lt;AsyncHandler&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>In this chapter, we'll have a look at commands, which are a simple yet extremely powerful mechanism to offload both CPU-bound and I/O-bound tasks to a separate runtime.</p>
<p>Commands are background tasks that can be spawned using a <code>ComponentSender</code> or <code>FactorySender</code>.
They run until they return their result as a <code>CommandOutput</code> message that will be processed by the component.</p>
<p>First, we define our message type so we can use it for the associated <code>CommandOutput</code> type in our component.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum CommandMsg {
    Data(RemoteData),
}</code></pre>
<pre><code class="language-rust no_run noplayground">impl Component for CommandModel {
    type CommandOutput = CommandMsg;</code></pre>
<blockquote>
<p>Note: This only works with the <code>Component</code> trait.
The simplified <code>SimpleComponent</code> trait doesn't support commands.</p>
</blockquote>
<p>In our update function, we start a new command using the <code>oneshot_command()</code> method.
This method allows us to spawn a future that will yield exactly one <code>CommandOutput</code> message at completion.
From the command, we call an asynchronous function that will handle the web request for us.
Once the future completes, the command returns a <code>CommandMsg</code>.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;mut self, msg: Self::Input, sender: ComponentSender&lt;Self&gt;, _: &amp;Self::Root) {
        match msg {
            CommandModelMsg::FetchData =&gt; {
                sender.oneshot_command(async {
                    // Run async background task
                    CommandMsg::Data(fetch_data().await)
                });
            }
        }
    }</code></pre>
<p>Now, we can process the <code>CommandMsg</code> similar to regular app updates.
The method we use is called <code>update_cmd()</code> and is very similar to the regular <code>update()</code> function.
Only the message type is <code>CommandOutput</code> instead of <code>Input</code>.
From here, we can simply assign the result of the web request to our model.</p>
<pre><code class="language-rust no_run noplayground">    fn update_cmd(
        &amp;mut self,
        message: Self::CommandOutput,
        _sender: ComponentSender&lt;Self&gt;,
        _: &amp;Self::Root,
    ) {
        match message {
            CommandMsg::Data(data) =&gt; self.remote_data = data,
        }
    }</code></pre>
<p>That's it!
It's really as simple as starting a task and processing a message on completion.</p>
<blockquote>
<p>With the <a href="https://docs.rs/relm4/latest/relm4/struct.ComponentSender.html#method.command"><code>command()</code></a> method, you are even more flexible because you can send multiple messages.</p>
</blockquote>
<h2 id="synchronous-tasks"><a class="header" href="#synchronous-tasks">Synchronous tasks</a></h2>
<p>You can use commands for synchronous operations, too.
Compared to the asynchronous methods, we need to add the <code>spawn_</code> prefix to the method name to get the synchronous version.
Then, you can just pass a closure or a function pointer as task.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;mut self, msg: Self::Input, sender: ComponentSender&lt;Self&gt;, _: &amp;Self::Root) {
        match msg {
            CommandModelMsg::FetchData =&gt; {
                sender.spawn_oneshot_command(|| {
                    // Run CPU-bound background task
                    CommandMsg::Data(compute_result())
                });
            }
        }
    }</code></pre>
<p>The rest is identical to the asynchronous version.</p>
<pre><code class="language-rust no_run noplayground">    fn update_cmd(
        &amp;mut self,
        message: Self::CommandOutput,
        _sender: ComponentSender&lt;Self&gt;,
        _: &amp;Self::Root,
    ) {
        match message {
            CommandMsg::Data(data) =&gt; self.remote_data = data,
        }
    }</code></pre>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>Commands run on a tokio runtime.
If you spawn a lot of commands in your application or want to fine-tune the runtime, you can set <a href="https://docs.rs/relm4/latest/relm4/index.html#statics">two static variables</a> at the start of your main function to override the default value.
For example, Relm4 only uses one thread for asynchronous background tasks, which might not be enough.
Setting <code>RELM_THREADS</code> to 4 will increase the thread count by 3 additional threads.</p>
<blockquote>
<p>Note: Setting the static variables must be done early.
As soon as the runtime is initialized (which happens when it's accessed for the first time), the values cannot be changed anymore.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-components-and-factories"><a class="header" href="#async-components-and-factories">Async components and factories</a></h1>
<p>Asynchronous components and factories are almost identical compared to regular components and factories.
The only major difference is that they have asynchronous <code>init</code>, <code>update</code> and <code>update_cmd</code> methods.
This allows you to <code>await</code> almost everywhere from within the component.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/Relm4/Relm4/blob/main/examples/simple_async.rs">here</a>. Run <code>cargo run --example simple_async</code> from the <a href="https://github.com/Relm4/Relm4/tree/main/examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<p>Because Rust doesn't support async traits yet, we need macros to add support for this feature.
To tell the <code>component</code> macro that we're using an async trait, we pass the <code>async</code> parameter to it.
The <code>component</code> macro will then utilize the <code>async_trait</code> crate behind the scenes to make everything work.
Also, we need to use <code>AsyncComponent</code> instead of <code>Component</code> as trait.
Apart from that, the first section is identical.</p>
<blockquote>
<p>Similarly, the <code>factory</code> macro needs the <code>async</code> parameter for async factories and the trait changes from <code>FactoryComponent</code> to <code>AsyncFactoryComponent</code>.</p>
</blockquote>
<pre><code class="language-rust no_run noplayground">#[relm4::component(async)]
impl AsyncComponent for App {
    type Init = u8;
    type Input = Msg;
    type Output = ();
    type CommandOutput = ();</code></pre>
<p>Most functions of async component and factory traits are asynchronous, which allows us to <code>await</code> on futures within those functions.
Apart from that, only a couple of types need to be adjusted for the async versions of the traits, for example <code>AsyncComponentSender</code> and <code>AsyncComponentParts</code>.</p>
<pre><code class="language-rust no_run noplayground">    async fn init(
        counter: Self::Init,
        root: Self::Root,
        sender: AsyncComponentSender&lt;Self&gt;,
    ) -&gt; AsyncComponentParts&lt;Self&gt; {
        tokio::time::sleep(Duration::from_secs(1)).await;

        let model = App { counter };

        // Insert the code generation of the view! macro here
        let widgets = view_output!();

        AsyncComponentParts { model, widgets }
    }</code></pre>
<p>Awaiting in the init function allows us to perform a late initialization.
Depending on how you implement the init function, it might take a long time to complete.
Not showing anything in this case can look very odd.
Therefore, Relm4 allows you to specify widgets that will be displayed while your async component is initialized.</p>
<blockquote>
<p>If your init function doesn't await or completes quickly, you don't need to implement <code>init_loading_widgets</code>.</p>
</blockquote>
<pre><code class="language-rust no_run noplayground">    fn init_loading_widgets(root: Self::Root) -&gt; Option&lt;LoadingWidgets&gt; {
        view! {
            #[local]
            root {
                set_title: Some("Simple app"),
                set_default_size: (300, 100),

                // This will be removed automatically by
                // LoadingWidgets when the full view has loaded
                #[name(spinner)]
                gtk::Spinner {
                    start: (),
                    set_halign: gtk::Align::Center,
                }
            }
        }
        Some(LoadingWidgets::new(root, spinner))
    }</code></pre>
<p>In this case, we do some basic initialization of our root widget upfront and also add a <code>Spinner</code> for a nice loading animation.
As soon as the <code>init</code> function returns, the temporary spinner will be removed automatically and the widgets from the <code>view!</code> macro will be inserted instead.</p>
<p>Finally, the <code>update</code> function completes the trait implementation.
Notably, awaiting slow futures will block the processing of further messages.
In other words, the update function can only process one message afters the other.
Because we use async however, this only affects each async component individually and all other components won't be affected.
If you want to process multiple messages at the same time, you should consider using commands.</p>
<pre><code class="language-rust no_run noplayground">    async fn update(
        &amp;mut self,
        msg: Self::Input,
        _sender: AsyncComponentSender&lt;Self&gt;,
        _root: &amp;Self::Root,
    ) {
        tokio::time::sleep(Duration::from_secs(1)).await;
        match msg {
            Msg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            Msg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
    }</code></pre>
<h2 id="the-complete-code-5"><a class="header" href="#the-complete-code-5">The complete code</a></h2>
<pre><code class="language-rust no_run noplayground">use std::time::Duration;

use gtk::prelude::*;
use relm4::{
    component::{AsyncComponent, AsyncComponentParts, AsyncComponentSender},
    gtk,
    loading_widgets::LoadingWidgets,
    view, RelmApp, RelmWidgetExt,
};

struct App {
    counter: u8,
}

#[derive(Debug)]
enum Msg {
    Increment,
    Decrement,
}

#[relm4::component(async)]
impl AsyncComponent for App {
    type Init = u8;
    type Input = Msg;
    type Output = ();
    type CommandOutput = ();

    view! {
        gtk::Window {
            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,
                set_spacing: 5,
                set_margin_all: 5,

                gtk::Button {
                    set_label: "Increment",
                    connect_clicked =&gt; Msg::Increment,
                },

                gtk::Button {
                    set_label: "Decrement",
                    connect_clicked =&gt; Msg::Decrement,
                },

                gtk::Label {
                    #[watch]
                    set_label: &amp;format!("Counter: {}", model.counter),
                    set_margin_all: 5,
                }
            }
        }
    }

    fn init_loading_widgets(root: Self::Root) -&gt; Option&lt;LoadingWidgets&gt; {
        view! {
            #[local]
            root {
                set_title: Some("Simple app"),
                set_default_size: (300, 100),

                // This will be removed automatically by
                // LoadingWidgets when the full view has loaded
                #[name(spinner)]
                gtk::Spinner {
                    start: (),
                    set_halign: gtk::Align::Center,
                }
            }
        }
        Some(LoadingWidgets::new(root, spinner))
    }

    async fn init(
        counter: Self::Init,
        root: Self::Root,
        sender: AsyncComponentSender&lt;Self&gt;,
    ) -&gt; AsyncComponentParts&lt;Self&gt; {
        tokio::time::sleep(Duration::from_secs(1)).await;

        let model = App { counter };

        // Insert the code generation of the view! macro here
        let widgets = view_output!();

        AsyncComponentParts { model, widgets }
    }

    async fn update(
        &amp;mut self,
        msg: Self::Input,
        _sender: AsyncComponentSender&lt;Self&gt;,
        _root: &amp;Self::Root,
    ) {
        tokio::time::sleep(Duration::from_secs(1)).await;
        match msg {
            Msg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            Msg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
    }
}

fn main() {
    let app = RelmApp::new("relm4.example.simple_async");
    app.run_async::&lt;App&gt;(0);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th style="text-align: center">Synchronous</th><th style="text-align: center">Async</th><th style="text-align: center">Non-blocking</th><th style="text-align: center">!Send</th></tr></thead><tbody>
<tr><td>Workers</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>Async components and factories</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
<tr><td>Commands</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
</tbody></table>
</div>
<p>In this context, non-blocking means you can have run multiple instances at the same time.</p>
<p><code>!Send</code> means that the types involved don't need to implement <code>Send</code> so you can use widgets or <code>Rc</code> for example.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<ul>
<li>
<p><strong>Async components and factories:</strong></p>
<ul>
<li>Run asynchronous tasks on the main runtime</li>
<li>Allow other components to keep running while awaiting futures</li>
<li>Await during initialization or updates</li>
</ul>
</li>
<li>
<p><strong>Commands:</strong></p>
<ul>
<li>Run tasks on a runtime in the background</li>
<li>Supports <strong>both synchronous and asynchronous</strong> tasks</li>
<li>Run <strong>several tasks in parallel</strong></li>
<li>Drop tasks as soon as the component is destroyed</li>
</ul>
</li>
<li>
<p><strong>Workers:</strong></p>
<ul>
<li>Handle IO-bound or CPU-intensive tasks <strong>one at the time</strong> on a different thread</li>
<li>The update function should be executed in another thread</li>
<li>You need a model to store state for processing messages</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="child-components"><a class="header" href="#child-components">Child components</a></h1>
<p>In this chapter, we will implement a simple alert dialog as a reusable child component.</p>
<p>The alert example in the Relm4 repository implements a simple app for the alert component that we will write in this chapter. It's an other variant of a counter app, yet this time a dialog will be displayed if the counter does not match 42 when closing. The main difference in the implementation is, that the dialog is implemented as component that can be reused in other applications.</p>
<p><img src="img/screenshots/reusable-alert-dark-1.png" alt="App screenshot dark" /></p>
<p>This is how the dialog looks like in the alert example:</p>
<p><img src="img/screenshots/reusable-alert-dark-2.png" alt="App screenshot dark" /></p>
<blockquote>
<p>If you want to see an alert component very similar to the one we will write in this chapter, have a look at the <a href="https://github.com/Relm4/Relm4/blob/main/relm4-components/examples/alert.rs">“alert” example</a>. Run <code>cargo run --example alert</code> from the <a href="https://github.com/Relm4/Relm4/tree/main/relm4-components/examples">relm4-components/examples directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="the-alert-component"><a class="header" href="#the-alert-component">The alert component</a></h2>
<p>The alert component is defined similar to the other components we've implemented in this book.</p>
<p>Our model stores whether the component is visible and the configuration.</p>
<pre><code class="language-rust ignore">/// Alert dialog component.
pub struct Alert {
    settings: AlertSettings,
    is_active: bool,
}</code></pre>
<p>We define a <code>Widgets</code>, <code>Init</code>, <code>Input</code> and <code>Output</code> type as usual.</p>
<pre><code class="language-rust ignore">    type Widgets = AlertWidgets;
    type Init = AlertSettings;
    type Input = AlertMsg;
    type Output = AlertResponse;</code></pre>
<p>The <code>Init</code> param is a settings object that is used to configure the component.
This maximizes the reusability of the component by letting it adapt to different use-cases.</p>
<pre><code class="language-rust ignore">/// Configuration for the alert dialog component
pub struct AlertSettings {
    /// Large text
    pub text: String,
    /// Optional secondary, smaller text
    pub secondary_text: Option&lt;String&gt;,
    /// Modal dialogs freeze other windows as long they are visible
    pub is_modal: bool,
    /// Sets color of the accept button to red if the theme supports it
    pub destructive_accept: bool,
    /// Text for confirm button
    pub confirm_label: String,
    /// Text for cancel button
    pub cancel_label: String,
    /// Text for third option button. If [`None`] the third button won't be created.
    pub option_label: Option&lt;String&gt;,
}</code></pre>
<p>In the <code>Input</code> type, this component uses <code>#[doc(hidden)]</code> on the <code>Response</code> variant. This is a useful pattern for component-internal messages that are not intended to be sent by outside callers. This allows us to update the component when the underlying dialog reports a response, but not display the <code>Response</code> variant in the component's documentation.</p>
<pre><code class="language-rust ignore">/// Messages that can be sent to the alert dialog component
#[derive(Debug)]
pub enum AlertMsg {
    /// Message sent by the parent to view the dialog
    Show,

    #[doc(hidden)]
    Response(gtk::ResponseType),
}</code></pre>
<p>The <code>Output</code> type allows us to report the user's response back to a parent component.</p>
<pre><code class="language-rust ignore">/// User action performed on the alert dialog.
#[derive(Debug)]
pub enum AlertResponse {
    /// User clicked confirm button.
    Confirm,

    /// User clicked cancel button.
    Cancel,

    /// User clicked user-supplied option.
    Option,
}</code></pre>
<p>The update function handles the <code>Show</code> message from our parent component and the <code>Response</code> messages generated by user interactions. It also sends the appropriate messages to the parent through the output sender.</p>
<pre><code class="language-rust ignore">    fn update(&amp;mut self, input: AlertMsg, sender: ComponentSender&lt;Self&gt;) {
        match input {
            AlertMsg::Show =&gt; {
                self.is_active = true;
            }
            AlertMsg::Response(ty) =&gt; {
                self.is_active = false;
                sender
                    .output(match ty {
                        gtk::ResponseType::Accept =&gt; AlertResponse::Confirm,
                        gtk::ResponseType::Other(_) =&gt; AlertResponse::Option,
                        _ =&gt; AlertResponse::Cancel,
                    })
                    .unwrap();
            }
        }
    }</code></pre>
<p>When initializing the model, we conditionally set up some widgets based on the settings passed by the caller. We set <code>is_active</code> to <code>false</code> since the dialog is not currently displayed.</p>
<pre><code class="language-rust ignore">    fn init(
        settings: AlertSettings,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let model = Alert {
            settings,
            is_active: false,
        };

        let widgets = view_output!();

        if let Some(option_label) = &amp;model.settings.option_label {
            widgets
                .dialog
                .add_button(option_label, gtk::ResponseType::Other(0));
        }

        if model.settings.destructive_accept {
            let accept_widget = widgets
                .dialog
                .widget_for_response(gtk::ResponseType::Accept)
                .expect("No button for accept response set");
            accept_widget.add_css_class("destructive-action");
        }

        ComponentParts { model, widgets }
    }</code></pre>
<p>Lastly, the view. Note that the component connects to the <a href="https://docs.gtk.org/gtk4/signal.Dialog.response.html"><code>response</code>
signal</a> of the underlying dialog and sends an <em>input</em> to itself when a response is received.</p>
<pre><code class="language-rust ignore">    view! {
        #[name = "dialog"]
        gtk::MessageDialog {
            set_message_type: gtk::MessageType::Question,
            #[watch]
            set_visible: model.is_active,
            connect_response[sender] =&gt; move |_, response| {
                sender.input(AlertMsg::Response(response));
            },

            // Apply configuration
            set_text: Some(&amp;model.settings.text),
            set_secondary_text: model.settings.secondary_text.as_deref(),
            set_modal: model.settings.is_modal,
            add_button: (&amp;model.settings.confirm_label, gtk::ResponseType::Accept),
            add_button: (&amp;model.settings.cancel_label, gtk::ResponseType::Cancel),
        }
    }</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>With the component complete, let's use it!</p>
<pre><code class="language-rust ignore">struct App {
    counter: u8,
    alert_toggle: bool,
    dialog: Controller&lt;Alert&gt;,
    second_dialog: Controller&lt;Alert&gt;,
}

#[derive(Debug)]
enum AppMsg {
    Increment,
    Decrement,
    CloseRequest,
    Save,
    Close,
    Ignore,
}

#[relm4::component]
impl SimpleComponent for App {
    type Input = AppMsg;
    type Output = ();
    type Init = ();

    view! {
        main_window = gtk::ApplicationWindow {
            set_title: Some("Simple app"),
            set_default_width: 300,
            set_default_height: 100,

            connect_close_request[sender] =&gt; move |_| {
                sender.input(AppMsg::CloseRequest);
                gtk::glib::Propagation::Stop
            },

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,
                set_margin_all: 5,
                set_spacing: 5,

                append = &amp;gtk::Button {
                    set_label: "Increment",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Increment);
                    },
                },
                append = &amp;gtk::Button {
                    set_label: "Decrement",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Decrement);
                    },
                },
                append = &amp;gtk::Label {
                    set_margin_all: 5,
                    #[watch]
                    set_label: &amp;format!("Counter: {}", model.counter),
                },
                append = &amp;gtk::Button {
                    set_label: "Close",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::CloseRequest);
                    },
                },
            },
        }
    }

    fn update(&amp;mut self, msg: AppMsg, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
            AppMsg::CloseRequest =&gt; {
                if self.counter == 42 {
                    relm4::main_application().quit();
                } else {
                    self.alert_toggle = !self.alert_toggle;
                    if self.alert_toggle {
                        self.dialog.emit(AlertMsg::Show);
                    } else {
                        self.second_dialog.emit(AlertMsg::Show);
                    }
                }
            }
            AppMsg::Save =&gt; {
                println!("* Open save dialog here *");
            }
            AppMsg::Close =&gt; {
                relm4::main_application().quit();
            }
            AppMsg::Ignore =&gt; (),
        }
    }

    fn init(_: (), root: Self::Root, sender: ComponentSender&lt;Self&gt;) -&gt; ComponentParts&lt;Self&gt; {
        let model = App {
            counter: 0,
            alert_toggle: false,
            dialog: Alert::builder()
                .transient_for(&amp;root)
                .launch(AlertSettings {
                    text: String::from("Do you want to quit without saving? (First alert)"),
                    secondary_text: Some(String::from("Your counter hasn't reached 42 yet")),
                    confirm_label: String::from("Close without saving"),
                    cancel_label: String::from("Cancel"),
                    option_label: Some(String::from("Save")),
                    is_modal: true,
                    destructive_accept: true,
                })
                .forward(sender.input_sender(), convert_alert_response),
            second_dialog: Alert::builder()
                .transient_for(&amp;root)
                .launch(AlertSettings {
                    text: String::from("Do you want to quit without saving? (Second alert)"),
                    secondary_text: Some(String::from("Your counter hasn't reached 42 yet")),
                    confirm_label: String::from("Close without saving"),
                    cancel_label: String::from("Cancel"),
                    option_label: Some(String::from("Save")),
                    is_modal: true,
                    destructive_accept: true,
                })
                .forward(sender.input_sender(), convert_alert_response),
        };

        let widgets = view_output!();

        ComponentParts { model, widgets }
    }
}

fn convert_alert_response(response: AlertResponse) -&gt; AppMsg {
    match response {
        AlertResponse::Confirm =&gt; AppMsg::Close,
        AlertResponse::Cancel =&gt; AppMsg::Ignore,
        AlertResponse::Option =&gt; AppMsg::Save,
    }
}

fn main() {
    let app = RelmApp::new("relm4.example.alert");
    app.run::&lt;App&gt;(());
}</code></pre>
<p>This is mostly stuff that we've already done in previous chapters, but there are a few additional things to know about interacting with child components.</p>
<p>Notably, we need to wrap the types of the child components in <code>Controller</code>s to be able to store them in the <code>App</code> model.</p>
<pre><code class="language-rust ignore">struct App {
    counter: u8,
    alert_toggle: bool,
    dialog: Controller&lt;Alert&gt;,
    second_dialog: Controller&lt;Alert&gt;,
}</code></pre>
<p>We initialize them with the builder pattern in the <code>init</code> method.</p>
<pre><code class="language-rust ignore">    fn init(_: (), root: Self::Root, sender: ComponentSender&lt;Self&gt;) -&gt; ComponentParts&lt;Self&gt; {
        let model = App {
            counter: 0,
            alert_toggle: false,
            dialog: Alert::builder()
                .transient_for(&amp;root)
                .launch(AlertSettings {
                    text: String::from("Do you want to quit without saving? (First alert)"),
                    secondary_text: Some(String::from("Your counter hasn't reached 42 yet")),
                    confirm_label: String::from("Close without saving"),
                    cancel_label: String::from("Cancel"),
                    option_label: Some(String::from("Save")),
                    is_modal: true,
                    destructive_accept: true,
                })
                .forward(sender.input_sender(), convert_alert_response),
            second_dialog: Alert::builder()
                .transient_for(&amp;root)
                .launch(AlertSettings {
                    text: String::from("Do you want to quit without saving? (Second alert)"),
                    secondary_text: Some(String::from("Your counter hasn't reached 42 yet")),
                    confirm_label: String::from("Close without saving"),
                    cancel_label: String::from("Cancel"),
                    option_label: Some(String::from("Save")),
                    is_modal: true,
                    destructive_accept: true,
                })
                .forward(sender.input_sender(), convert_alert_response),
        };

        let widgets = view_output!();

        ComponentParts { model, widgets }
    }</code></pre>
<p>We call <code>transient_for(root)</code> on the builder to indicate to GTK that our root widget is transient for the main application window. This allows window managers to handle the dialog window differently, e.g. by drawing it on top of other windows.
See the <a href="https://docs.gtk.org/gtk4/method.Window.set_transient_for.html"><code>set_transient_for</code> documentation</a> for more information.</p>
<pre><code class="language-rust ignore">            AppMsg::CloseRequest =&gt; {
                if self.counter == 42 {
                    relm4::main_application().quit();
                } else {
                    self.alert_toggle = !self.alert_toggle;
                    if self.alert_toggle {
                        self.dialog.emit(AlertMsg::Show);
                    } else {
                        self.second_dialog.emit(AlertMsg::Show);
                    }
                }
            }</code></pre>
<p>That's it! You can find more examples of reusable components in the
relm4-components crate <a href="https://docs.rs/relm4-components/latest/relm4_components/">here</a>.
You can also contribute your own reusable components to relm4-components :)</p>
<h2 id="the-complete-code-6"><a class="header" href="#the-complete-code-6">The complete code</a></h2>
<p>Let’s review all our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust ignore">use gtk::prelude::*;
use relm4::prelude::*;
use relm4::Controller;

/// Configuration for the alert dialog component
pub struct AlertSettings {
    /// Large text
    pub text: String,
    /// Optional secondary, smaller text
    pub secondary_text: Option&lt;String&gt;,
    /// Modal dialogs freeze other windows as long they are visible
    pub is_modal: bool,
    /// Sets color of the accept button to red if the theme supports it
    pub destructive_accept: bool,
    /// Text for confirm button
    pub confirm_label: String,
    /// Text for cancel button
    pub cancel_label: String,
    /// Text for third option button. If [`None`] the third button won't be created.
    pub option_label: Option&lt;String&gt;,
}

/// Alert dialog component.
pub struct Alert {
    settings: AlertSettings,
    is_active: bool,
}

/// Messages that can be sent to the alert dialog component
#[derive(Debug)]
pub enum AlertMsg {
    /// Message sent by the parent to view the dialog
    Show,

    #[doc(hidden)]
    Response(gtk::ResponseType),
}

/// User action performed on the alert dialog.
#[derive(Debug)]
pub enum AlertResponse {
    /// User clicked confirm button.
    Confirm,

    /// User clicked cancel button.
    Cancel,

    /// User clicked user-supplied option.
    Option,
}

/// Widgets of the alert dialog component.
#[relm4::component(pub)]
impl SimpleComponent for Alert {
    type Widgets = AlertWidgets;
    type Init = AlertSettings;
    type Input = AlertMsg;
    type Output = AlertResponse;

    view! {
        #[name = "dialog"]
        gtk::MessageDialog {
            set_message_type: gtk::MessageType::Question,
            #[watch]
            set_visible: model.is_active,
            connect_response[sender] =&gt; move |_, response| {
                sender.input(AlertMsg::Response(response));
            },

            // Apply configuration
            set_text: Some(&amp;model.settings.text),
            set_secondary_text: model.settings.secondary_text.as_deref(),
            set_modal: model.settings.is_modal,
            add_button: (&amp;model.settings.confirm_label, gtk::ResponseType::Accept),
            add_button: (&amp;model.settings.cancel_label, gtk::ResponseType::Cancel),
        }
    }

    fn init(
        settings: AlertSettings,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let model = Alert {
            settings,
            is_active: false,
        };

        let widgets = view_output!();

        if let Some(option_label) = &amp;model.settings.option_label {
            widgets
                .dialog
                .add_button(option_label, gtk::ResponseType::Other(0));
        }

        if model.settings.destructive_accept {
            let accept_widget = widgets
                .dialog
                .widget_for_response(gtk::ResponseType::Accept)
                .expect("No button for accept response set");
            accept_widget.add_css_class("destructive-action");
        }

        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, input: AlertMsg, sender: ComponentSender&lt;Self&gt;) {
        match input {
            AlertMsg::Show =&gt; {
                self.is_active = true;
            }
            AlertMsg::Response(ty) =&gt; {
                self.is_active = false;
                sender
                    .output(match ty {
                        gtk::ResponseType::Accept =&gt; AlertResponse::Confirm,
                        gtk::ResponseType::Other(_) =&gt; AlertResponse::Option,
                        _ =&gt; AlertResponse::Cancel,
                    })
                    .unwrap();
            }
        }
    }
}

struct App {
    counter: u8,
    alert_toggle: bool,
    dialog: Controller&lt;Alert&gt;,
    second_dialog: Controller&lt;Alert&gt;,
}

#[derive(Debug)]
enum AppMsg {
    Increment,
    Decrement,
    CloseRequest,
    Save,
    Close,
    Ignore,
}

#[relm4::component]
impl SimpleComponent for App {
    type Input = AppMsg;
    type Output = ();
    type Init = ();

    view! {
        main_window = gtk::ApplicationWindow {
            set_title: Some("Simple app"),
            set_default_width: 300,
            set_default_height: 100,

            connect_close_request[sender] =&gt; move |_| {
                sender.input(AppMsg::CloseRequest);
                gtk::glib::Propagation::Stop
            },

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,
                set_margin_all: 5,
                set_spacing: 5,

                append = &amp;gtk::Button {
                    set_label: "Increment",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Increment);
                    },
                },
                append = &amp;gtk::Button {
                    set_label: "Decrement",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Decrement);
                    },
                },
                append = &amp;gtk::Label {
                    set_margin_all: 5,
                    #[watch]
                    set_label: &amp;format!("Counter: {}", model.counter),
                },
                append = &amp;gtk::Button {
                    set_label: "Close",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::CloseRequest);
                    },
                },
            },
        }
    }

    fn update(&amp;mut self, msg: AppMsg, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
            AppMsg::CloseRequest =&gt; {
                if self.counter == 42 {
                    relm4::main_application().quit();
                } else {
                    self.alert_toggle = !self.alert_toggle;
                    if self.alert_toggle {
                        self.dialog.emit(AlertMsg::Show);
                    } else {
                        self.second_dialog.emit(AlertMsg::Show);
                    }
                }
            }
            AppMsg::Save =&gt; {
                println!("* Open save dialog here *");
            }
            AppMsg::Close =&gt; {
                relm4::main_application().quit();
            }
            AppMsg::Ignore =&gt; (),
        }
    }

    fn init(_: (), root: Self::Root, sender: ComponentSender&lt;Self&gt;) -&gt; ComponentParts&lt;Self&gt; {
        let model = App {
            counter: 0,
            alert_toggle: false,
            dialog: Alert::builder()
                .transient_for(&amp;root)
                .launch(AlertSettings {
                    text: String::from("Do you want to quit without saving? (First alert)"),
                    secondary_text: Some(String::from("Your counter hasn't reached 42 yet")),
                    confirm_label: String::from("Close without saving"),
                    cancel_label: String::from("Cancel"),
                    option_label: Some(String::from("Save")),
                    is_modal: true,
                    destructive_accept: true,
                })
                .forward(sender.input_sender(), convert_alert_response),
            second_dialog: Alert::builder()
                .transient_for(&amp;root)
                .launch(AlertSettings {
                    text: String::from("Do you want to quit without saving? (Second alert)"),
                    secondary_text: Some(String::from("Your counter hasn't reached 42 yet")),
                    confirm_label: String::from("Close without saving"),
                    cancel_label: String::from("Cancel"),
                    option_label: Some(String::from("Save")),
                    is_modal: true,
                    destructive_accept: true,
                })
                .forward(sender.input_sender(), convert_alert_response),
        };

        let widgets = view_output!();

        ComponentParts { model, widgets }
    }
}

fn convert_alert_response(response: AlertResponse) -&gt; AppMsg {
    match response {
        AlertResponse::Confirm =&gt; AppMsg::Close,
        AlertResponse::Cancel =&gt; AppMsg::Ignore,
        AlertResponse::Option =&gt; AppMsg::Save,
    }
}

fn main() {
    let app = RelmApp::new("relm4.example.alert");
    app.run::&lt;App&gt;(());
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget-templates"><a class="header" href="#widget-templates">Widget templates</a></h1>
<p>Widget templates are a simple way to define reusable UI elements.
When building complex UIs, they allow you to focus on the application logic instead of complex trees of widgets.
Yet most importantly, widget templates help you to reduce redundant code.
For example, if you use a widget with the same properties multiple times in your code, templates will make your code a lot shorter.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/Relm4/Relm4/blob/main/examples/widget_template.rs">here</a>.
Run <code>cargo run --example widget_template</code> from the <a href="https://github.com/Relm4/Relm4/tree/main/examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="defining-templates"><a class="header" href="#defining-templates">Defining templates</a></h2>
<p>To define a widget template, you need to implement the <code>WidgetTemplate</code> trait for a new type.
You could do this manually, but the easiest solution is to use the <code>#[relm4::widget_template]</code> attribute macro.
The macro will create the type and implement the trait for you.</p>
<p>For example, the following code block will create a template for a <code>gtk::Box</code> with a certain margin and custom CSS.</p>
<pre><code class="language-rust no_run noplayground">#[relm4::widget_template]
impl WidgetTemplate for MyBox {
    view! {
        gtk::Box {
            set_margin_all: 10,
            // Make the boxes visible
            inline_css: "border: 2px solid blue",
        }
    }
}</code></pre>
<p>Similarly, we can create a template for a <code>gtk::Spinner</code> that already spins when it's created.</p>
<pre><code class="language-rust no_run noplayground">#[relm4::widget_template]
impl WidgetTemplate for MySpinner {
    view! {
        gtk::Spinner {
            set_spinning: true,
        }
    }
}</code></pre>
<blockquote>
<p>To create public templates, you can use <code>#[relm4::widget_template(pub)]</code>, similar to the <code>#[relm4::component(pub)]</code> macro.</p>
</blockquote>
<h3 id="template-children"><a class="header" href="#template-children">Template children</a></h3>
<p>Templates are more than just pre-initialized widgets.
They can also have children, which can be referred to later as template children.
This is very useful if you use nested widget in you UI, because the template allows you to flatten the structure.
In other words, no matter how deeply nested a template child is, it will always be accessible directly from the template.
We'll see how this works in the next section, but first we'll create a deeply nested template.
We use the templates we defined earlier by using the <code>#[template]</code> attribute.
Also, we assign the name <code>child_label</code> to our last widget, which is all we need to make it a template child.
In general, naming a widget in a template is all that's needed to make it a template child.</p>
<pre><code class="language-rust no_run noplayground">#[relm4::widget_template]
impl WidgetTemplate for CustomBox {
    view! {
        gtk::Box {
            set_orientation: gtk::Orientation::Vertical,
            set_margin_all: 5,
            set_spacing: 5,

            #[template]
            MyBox {
                #[template]
                MySpinner,

                #[template]
                MyBox {
                    #[template]
                    MySpinner,

                    #[template]
                    MyBox {
                        #[template]
                        MySpinner,

                        // Deeply nested!
                        #[name = "child_label"]
                        gtk::Label {
                            set_label: "This is a test",
                        }
                    }
                }
            }
        }
    }
}</code></pre>
<h2 id="using-templates"><a class="header" href="#using-templates">Using templates</a></h2>
<p>To use templates in a component, we use the <code>#[template]</code> and <code>#[template_child]</code> attributes.
In this case, we use the <code>CustomBox</code> type we just defined with the <code>#[template]</code> attribute we already used.
To access its <code>child_label</code> template child, we only need to use the <code>#[template_child]</code> attribute and the name of the child.
As you can see, we now have access to the <code>whild_label</code> widget, which actually is wrapped into 4 <code>gtk::Box</code> widgets.
We can even use assign or overwrite properties of the template and its children, similar to regular widgets.
Here, we use the <code>#[watch]</code> attribute to update the label with the latest counter value.</p>
<pre><code class="language-rust no_run noplayground">#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = u8;
    type Input = AppMsg;
    type Output = ();

    view! {
        gtk::Window {
            set_title: Some("Widget template"),
            set_default_width: 300,
            set_default_height: 100,

            #[template]
            CustomBox {
                gtk::Button {
                    set_label: "Increment",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Increment);
                    },
                },
                gtk::Button {
                    set_label: "Decrement",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Decrement);
                    },
                },
                #[template_child]
                child_label {
                    #[watch]
                    set_label: &amp;format!("Counter: {}", model.counter),
                }
            },
        }
    }</code></pre>
<h3 id="some-notes-on-orders"><a class="header" href="#some-notes-on-orders">Some notes on orders</a></h3>
<p>If you run this code, you will notice that the label appears above the two buttons, which is contrary to our widget definition.
This happens because widget templates are initialized before other modifications happen.
The <code>CustomBox</code> template will initialize its <code>child_label</code> and append it to its internal <code>gtk::Box</code> widget and only then the two buttons are added.
However, you can work around this by using methods like <code>prepend</code>, <code>append</code> or <code>insert_child_after</code> (if you use a <code>gtk::Box</code> as container) or by splitting your templates into smaller ones.</p>
<blockquote>
<p>To make template children appear in the same order as they are used, widget templates would require dynamic initialization of its children.
This would increase the complexity of the internal implementation by a lot (or might not be possible at all) and is therefore not planned at the moment.</p>
</blockquote>
<h2 id="the-complete-code-7"><a class="header" href="#the-complete-code-7">The complete code</a></h2>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt, OrientableExt};
use relm4::{
    gtk, ComponentParts, ComponentSender, RelmApp, RelmWidgetExt, SimpleComponent, WidgetTemplate,
};

#[relm4::widget_template]
impl WidgetTemplate for MyBox {
    view! {
        gtk::Box {
            set_margin_all: 10,
            // Make the boxes visible
            inline_css: "border: 2px solid blue",
        }
    }
}

#[relm4::widget_template]
impl WidgetTemplate for MySpinner {
    view! {
        gtk::Spinner {
            set_spinning: true,
        }
    }
}

#[relm4::widget_template]
impl WidgetTemplate for CustomBox {
    view! {
        gtk::Box {
            set_orientation: gtk::Orientation::Vertical,
            set_margin_all: 5,
            set_spacing: 5,

            #[template]
            MyBox {
                #[template]
                MySpinner,

                #[template]
                MyBox {
                    #[template]
                    MySpinner,

                    #[template]
                    MyBox {
                        #[template]
                        MySpinner,

                        // Deeply nested!
                        #[name = "child_label"]
                        gtk::Label {
                            set_label: "This is a test",
                        }
                    }
                }
            }
        }
    }
}

#[derive(Default)]
struct AppModel {
    counter: u8,
}

#[derive(Debug)]
enum AppMsg {
    Increment,
    Decrement,
}

#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = u8;
    type Input = AppMsg;
    type Output = ();

    view! {
        gtk::Window {
            set_title: Some("Widget template"),
            set_default_width: 300,
            set_default_height: 100,

            #[template]
            CustomBox {
                gtk::Button {
                    set_label: "Increment",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Increment);
                    },
                },
                gtk::Button {
                    set_label: "Decrement",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Decrement);
                    },
                },
                #[template_child]
                child_label {
                    #[watch]
                    set_label: &amp;format!("Counter: {}", model.counter),
                }
            },
        }
    }

    fn init(
        counter: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let model = Self { counter };

        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, msg: AppMsg, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
    }
}

fn main() {
    let app = RelmApp::new("relm4.example.widget_template");
    app.run::&lt;AppModel&gt;(0);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accessing-nested-template-elements"><a class="header" href="#accessing-nested-template-elements">Accessing Nested Template Elements</a></h1>
<p>Starting from the version <strong>0.6.2</strong>, you can access nested elements on templates.</p>
<p>Imagine a template called "MainWindow" which contains pages as Widget Templates:</p>
<pre><code class="language-rust no_run noplayground">#[relm4::widget_template]
impl WidgetTemplate for MainWindow {
    view! {
        gtk::Window {
            set_title: Some("Nested Widget template"),
            set_default_width: 300,
            set_default_height: 100,

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,

                #[name(stk_pages)]
                gtk::Stack {
                    set_margin_all: 7,

                    #[template]
                    #[name = "home_page"]
                    add_child = &amp;HomePage {} -&gt; {
                        set_name: "main",
                    },

                    #[template]
                    #[name = "settings_page"]
                    add_child = &amp;SettingsPage {} -&gt; {
                        set_name: "settings",
                    },
                },

            },
        }
    }
}</code></pre>
<p><code>SettingsPage</code> and <code>HomePage</code> are also a widget template:</p>
<pre><code class="language-rust no_run noplayground">#[relm4::widget_template]
impl WidgetTemplate for HomePage {
    view! {
        gtk::Box {
            set_orientation: gtk::Orientation::Vertical,
            set_spacing: 3,

            #[name = "btn_go_settings"]
            gtk::Button {
                #[wrap(Some)]
                set_child = &amp;gtk::Image {
                    set_icon_name: Some("emblem-system-symbolic"),
                },
            },
        }
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">#[relm4::widget_template]
impl WidgetTemplate for SettingsPage {
    view! {
        gtk::Box {
            set_orientation: gtk::Orientation::Vertical,
            set_spacing: 3,

            #[name = "btn_dark_mode"]
            gtk::Button {
                #[wrap(Some)]
                set_child = &amp;gtk::Image {
                    set_icon_name: Some("night-light-symbolic"),
                },
            },

            #[name = "btn_go_homepage"]
            gtk::Button {
                #[wrap(Some)]
                set_child = &amp;gtk::Image {
                    set_icon_name: Some("user-home-symbolic"),
                },
            },
        }
    }
}</code></pre>
<p>If you want to handle <code>MainWindow-&gt;SettingsPage-&gt;btn_dark_mode</code>'s clicked event, you can simply do it like this:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct AppModel {
    current_page: &amp;'static str,
}

#[derive(Debug)]
enum Message {
    PageHome,
    PageSettings,
    DarkMode,
}

#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = ();
    type Input = Message;
    type Output = ();

    view! {

        #[template]
        MainWindow {

            #[template_child]
            settings_page.btn_dark_mode {
                connect_clicked =&gt; Message::DarkMode
            },

            #[template_child]
            settings_page.btn_go_homepage {
                connect_clicked =&gt; Message::PageHome
            },

            #[template_child]
            home_page.btn_go_settings {
                connect_clicked =&gt; Message::PageSettings
            },

            #[template_child]
            stk_pages {
                #[watch]
                set_visible_child_name: model.current_page,
            }
        },
    }</code></pre>
<h2 id="the-complete-code-8"><a class="header" href="#the-complete-code-8">The complete code</a></h2>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt, OrientableExt};
use relm4::{gtk, ComponentParts, ComponentSender, RelmWidgetExt, SimpleComponent, WidgetTemplate};

#[relm4::widget_template]
impl WidgetTemplate for HomePage {
    view! {
        gtk::Box {
            set_orientation: gtk::Orientation::Vertical,
            set_spacing: 3,

            #[name = "btn_go_settings"]
            gtk::Button {
                #[wrap(Some)]
                set_child = &amp;gtk::Image {
                    set_icon_name: Some("emblem-system-symbolic"),
                },
            },
        }
    }
}

#[relm4::widget_template]
impl WidgetTemplate for SettingsPage {
    view! {
        gtk::Box {
            set_orientation: gtk::Orientation::Vertical,
            set_spacing: 3,

            #[name = "btn_dark_mode"]
            gtk::Button {
                #[wrap(Some)]
                set_child = &amp;gtk::Image {
                    set_icon_name: Some("night-light-symbolic"),
                },
            },

            #[name = "btn_go_homepage"]
            gtk::Button {
                #[wrap(Some)]
                set_child = &amp;gtk::Image {
                    set_icon_name: Some("user-home-symbolic"),
                },
            },
        }
    }
}

#[relm4::widget_template]
impl WidgetTemplate for MainWindow {
    view! {
        gtk::Window {
            set_title: Some("Nested Widget template"),
            set_default_width: 300,
            set_default_height: 100,

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,

                #[name(stk_pages)]
                gtk::Stack {
                    set_margin_all: 7,

                    #[template]
                    #[name = "home_page"]
                    add_child = &amp;HomePage {} -&gt; {
                        set_name: "main",
                    },

                    #[template]
                    #[name = "settings_page"]
                    add_child = &amp;SettingsPage {} -&gt; {
                        set_name: "settings",
                    },
                },

            },
        }
    }
}

#[derive(Default)]
struct AppModel {
    current_page: &amp;'static str,
}

#[derive(Debug)]
enum Message {
    PageHome,
    PageSettings,
    DarkMode,
}

#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = ();
    type Input = Message;
    type Output = ();

    view! {

        #[template]
        MainWindow {

            #[template_child]
            settings_page.btn_dark_mode {
                connect_clicked =&gt; Message::DarkMode
            },

            #[template_child]
            settings_page.btn_go_homepage {
                connect_clicked =&gt; Message::PageHome
            },

            #[template_child]
            home_page.btn_go_settings {
                connect_clicked =&gt; Message::PageSettings
            },

            #[template_child]
            stk_pages {
                #[watch]
                set_visible_child_name: model.current_page,
            }
        },
    }

    fn init(
        _init_param: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let model = Self {
            current_page: "main",
        };

        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, msg: Message, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            Message::DarkMode =&gt; {
                println!("Mode changed");
            }
            Message::PageHome =&gt; {
                self.current_page = "main";
            }
            Message::PageSettings =&gt; {
                self.current_page = "settings";
            }
        }
    }
}

fn main() {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtk-rs-overview"><a class="header" href="#gtk-rs-overview">gtk-rs overview</a></h1>
<p>So far, we only discussed which features Relm4 provides. Yet, Relm4 is based on GTK, which itself has many useful features. Let’s have a look at it!</p>
<blockquote>
<p>This is just an overview. I’ve linked the relevant sections of the <a href="https://gtk-rs.org/gtk4-rs/git/book/">gtk-rs book</a> but if you want to get familiar with all the features, I recommend reading the book from the start.</p>
</blockquote>
<h2 id="gobjects"><a class="header" href="#gobjects">GObjects</a></h2>
<p>GTK is an object-oriented framework that uses the GObject library to implement objects. GObjects have some really useful features that we will discuss in the following sections.</p>
<h3 id="subclassing"><a class="header" href="#subclassing">Subclassing</a></h3>
<p>Like many other OOP frameworks or languages, GObjects can inherit from other GObjects. This is called subclassing. In the case of GTK, that’s really helpful because it allows us to create custom widgets.</p>
<p>For example, you could use subclassing to create your own button widget that acts as a counter. Or you can create a custom application window that better suits your application.</p>
<blockquote>
<p>Read more about subclassing in the <a href="https://gtk-rs.org/gtk4-rs/git/book/g_object_subclassing.html">gtk-rs book</a>.</p>
</blockquote>
<h3 id="properties-1"><a class="header" href="#properties-1">Properties</a></h3>
<p>Each GObject can have properties that work similar to the fields of a structure in Rust. You can set them and you can read (get) them. But one thing that's particularly cool is that properties can be bound to other properties.</p>
<p>For example, you could bind the "visible" property of a widget to the "active" property of a <code>gtk::ToggleButton</code>. This would allow you to show or hide the widget using the toggle button and the best part is, that it's done fully automatically!</p>
<blockquote>
<p>Read more about properties in the <a href="https://gtk-rs.org/gtk4-rs/git/book/g_object_properties.html">gtk-rs book</a>.</p>
</blockquote>
<h3 id="signals"><a class="header" href="#signals">Signals</a></h3>
<p>GObjects can not only have properties but also signals. Actually, we've been using signals all the time, for example, by using the <code>connect_clicked</code> method on a button. This method simply adds an event handler function for the "click" signal.</p>
<p>You can create your own signals in custom widgets. You can also use <a href="https://gtk-rs.org/gtk-rs-core/git/docs/glib/object/trait.ObjectExt.html#tymethod.emit">emit</a> to emit signals on you widgets manually.</p>
<blockquote>
<p>Read more about signals in the <a href="https://gtk-rs.org/gtk4-rs/git/book/g_object_signals.html">gtk-rs book</a>.</p>
</blockquote>
<h2 id="settings"><a class="header" href="#settings">Settings</a></h2>
<p>Most applications need to store settings at some point. GTK makes that pretty simple. You can use <code>gtk::Settings</code> to store your settings and keep them stored after your app has been closed.</p>
<blockquote>
<p>Read more about settings in the <a href="https://gtk-rs.org/gtk4-rs/git/book/settings.html">gtk-rs book</a>.</p>
</blockquote>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>Relm4 has factories for generating widgets from collections of data. GTK has a similar mechanism that should be used for large list. Because GTK knows which widgets of a list are actually shown it can optimize the rendering and memory usage a lot better.</p>
<blockquote>
<p>Read more about lists in the <a href="https://gtk-rs.org/gtk4-rs/git/book/list_widgets.html">gtk-rs book</a>.</p>
</blockquote>
<h2 id="composite-templates"><a class="header" href="#composite-templates">Composite templates</a></h2>
<p>Relm4 leaves it up to you how to create your UI. You can do it manually like in our first app, you can do with the widget macro or you can use the interface builder from GTK.</p>
<p>With composite templates, you can use a XML file to specify your widgets and properties.</p>
<blockquote>
<p>Read more about the composite templates in the <a href="https://gtk-rs.org/gtk4-rs/git/book/composite_templates.html">gtk-rs book</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource-bundles"><a class="header" href="#resource-bundles">Resource Bundles</a></h1>
<p>Some Relm4 apps require static assets or resources (such as icons or images) to function.</p>
<p>In GTK apps, static assets are transformed into GResource bundles, which are then loaded by the app. This guide shows how to set up GResource bundles within a Relm4 project.</p>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>This demonstrates a Cargo-only approach to including resources (i.e. it does not require extra build tools like Meson, or out-of-band shell scripts).</p>
<h3 id="data-directory"><a class="header" href="#data-directory"><code>data</code> directory</a></h3>
<p>We add the static resources (in this example, icon files), plus a <code>gresource</code> descriptor, to the project's <code>data</code> folder:</p>
<pre><code>data/
  icons/
    icon-foo.svg
    icon-bar.svg
  icons.gresource.xml
</code></pre>
<p>The icons are placed under the <code>data/icons</code> directory.</p>
<p>The <code>icons.gresource.xml</code> file looks like this (adapt it as required, e.g. using <code>-symbolic</code> icon names):</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
    &lt;gresource prefix="com/example/Foobar/icons/24x24/actions/"&gt;
        &lt;file preprocess="xml-stripblanks" alias="icon-foo.svg"&gt;icons/icon-foo.svg&lt;/file&gt;
        &lt;file preprocess="xml-stripblanks" alias="icon-bar.svg"&gt;icons/icon-bar.svg&lt;/file&gt;
    &lt;/gresource&gt;
&lt;/gresources&gt;
</code></pre>
<h3 id="cargotoml"><a class="header" href="#cargotoml"><code>Cargo.toml</code></a></h3>
<p>In <code>Cargo.toml</code>, we add a build dependency on <code>glib-build-tools</code>. This gives us access to the <code>glib_build_tools::compile_resources</code> function which we will need later:</p>
<pre><code class="language-toml">[package]
name = "foobar"

[build-dependencies]
glib-build-tools = "0.17.10"
</code></pre>
<p>Note: you should ensure that the <code>glib-build-tools</code> version aligns with the general GLib version you are building for.</p>
<h3 id="buildrs"><a class="header" href="#buildrs"><code>build.rs</code></a></h3>
<p>In <code>build.rs</code>, we call the <code>compile_resources</code> function which creates a GResource bundle from the icons:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use glib_build_tools::compile_resources;

fn main() {
    compile_resources(
        &amp;["data"],
        "data/icons.gresource.xml",
        "icons.gresource",
    );
}</code></pre></pre>
<h3 id="mainrs"><a class="header" href="#mainrs"><code>main.rs</code></a></h3>
<p>In <code>main.rs</code> (or wherever you initialise your Relm4 app), we load the <code>icons.gresource</code> bundle that Cargo generates:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn initialize_custom_icons() {
    gio::resources_register_include!("icons.gresource").unwrap();

    let display = gdk::Display::default().unwrap();
    let theme = gtk::IconTheme::for_display(&amp;display);
    theme.add_resource_path("/com/example/Foobar/icons");
}

fn main() {
    let app = RelmApp::new("com.example.Foobar");

    // (optional) initialize default icons
    relm4_icons::initialize_icons();

    // custom icons
    initialize_custom_icons();
}</code></pre></pre>
<p>It should now be possible to reference the resources by name within your app, for example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {
    gtk::Button {
        set_icon_name: "icon-foo"
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h1>
<p>We recommend that you establish a CI build for your Relm4 app. This guide describes how to do it, and the caveats you must observe to make the build work.</p>
<h2 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h2>
<p>Starting with Relm 0.6.1, you can set up a CI build for your app on GitHub Actions.</p>
<p>We recommend that you use the <a href="https://github.com/gtk-rs/gtk4-rs/pkgs/container/gtk4-rs%2Fgtk4"><code>gtk4-rs</code></a> container approach, as shown below:</p>
<pre><code class="language-yaml">name: Rust

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/gtk-rs/gtk4-rs/gtk4:latest # TODO enable minor version tags / pinning
    steps:
    - uses: actions/checkout@v3
    - uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: stable
    - name: Build
      run: cargo build
    - name: Test
      run: cargo test
</code></pre>
<p><strong>Note:</strong> You <em>can</em> alternatively just run the <code>cargo build</code> on the <code>ubuntu-latest</code> base image. However, this will tie your Relm app's GNOME and GTK version to Ubuntu's 2-year LTS release cycle, so you will not be able to use newer GNOME / GTK versions in the meantime. We therefore recommend that most projects use the <code>gtk4-rs</code> container approach instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-component-macro-reference"><a class="header" href="#the-component-macro-reference">The <code>component</code> macro reference</a></h1>
<p>There are quite a few of examples where the <code>component</code> macro is used in this book. Still, we haven't covered everything in the previous chapters, and it's also nice to have all the information in one place. This chapter serves as an exhaustive reference for the component macro syntax.</p>
<p>The <code>component</code> attribute macro expects a trait implementation of <code>SimpleComponent</code>, <code>Component</code>, or <code>FactoryComponent</code> on a user-provided <code>struct</code> that holds the component's state.</p>
<h2 id="public-widgets"><a class="header" href="#public-widgets">Public widgets</a></h2>
<p>If you want to make the <code>Widgets</code> struct generated by the macro public, you can provide <code>pub</code> (or any other visibility) as an argument to the attribute macro.</p>
<pre><code class="language-rust ignore">#[relm4::component(pub)]</code></pre>
<h2 id="the-view-macro"><a class="header" href="#the-view-macro">The <code>view!</code> macro</a></h2>
<p>The <code>view!</code> macro allows us to easily define widgets and mutate their properties.</p>
<h3 id="constructing-widgets"><a class="header" href="#constructing-widgets">Constructing widgets</a></h3>
<p>All components must have a root widget in their <code>view!</code> macro, such as <code>gtk::Window</code> or <code>gtk::Box</code>.
Widgets are constructed by providing the type of the widget followed by curly braces.
This will construct the widget using its <code>Default</code> implementation.</p>
<pre><code class="language-rust ignore">view! {
    gtk::Window {
        ...
    }
}</code></pre>
<p>Some, widgets don't have a <code>Default</code> implementation or it may be more convenient to use a constructor method.
In this case, you can use the following syntax:</p>
<pre><code class="language-rust ignore">// Constructor method
gtk::Label::new(Some("Label from constructor method")) { /* ... */ }

// Builder pattern
gtk::Label::builder()
    .label("Label from builder pattern")
    .selectable(true)
    .build() { /* ... */ }</code></pre>
<p>You can also use regular functions.
Because macro often needs to know the type of the widget for code generation, you may need to specify it.</p>
<pre><code class="language-rust ignore">set_property_name = new_box() -&gt; gtk::Box { ... }</code></pre>
<h3 id="child-widgets"><a class="header" href="#child-widgets">Child widgets</a></h3>
<p>Child widgets are added by nesting the declarations.</p>
<pre><code class="language-rust ignore">view! {
    gtk::Window {
        gtk::Box {

        }
    }
}</code></pre>
<p>If another method is needed to assign a child, you can call it instead like this:</p>
<pre><code class="language-rust ignore">gtk::Box {
    // Use append
    append = &amp;gtk::Label { ... }
}</code></pre>
<p>Use <code>&amp;</code> in front of the widget type to assign a reference.</p>
<blockquote>
<p>A common mistake is to accidentally use <code>:</code> instead of <code>=</code> for assigning widgets.</p>
</blockquote>
<p>If the widget needs to be wrapped in another type (commonly <code>Option</code>), use the <code>wrap</code> attribute:</p>
<pre><code class="language-rust ignore">#[wrap(Some)]
set_property_name = gtk::Box { ... }</code></pre>
<p>Sometimes you need to pass additional arguments along with the widget, for example when calling <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/prelude/trait.GridExt.html#method.attach"><code>gtk::Grid::attach</code></a>. You can do this by providing the additional arguments in square brackets after the method:</p>
<pre><code class="language-rust ignore">gtk::Grid {
    // Attach the label to a grid
    attach[0, 0, 1, 2]= &amp;gtk::Label { ... }
}</code></pre>
<p>This will expand to <code>__grid.attach(__label, 0, 0, 1, 2)</code></p>
<h3 id="naming-widgets"><a class="header" href="#naming-widgets">Naming widgets</a></h3>
<p>Widgets may be given a name with the <code>name</code> attribute. These names are accessible as fields on the <code>Widgets</code> struct generated by the macro.</p>
<pre><code class="language-rust ignore">#[name = "important_label"]
gtk::Label { ... }

// ...

let widgets = view_output!();
let label = &amp;widgets.important_label;</code></pre>
<p>Names can also be assigned with this syntax:</p>
<pre><code class="language-rust ignore">set_child: important_label = gtk::Label { ... }</code></pre>
<h3 id="conditional-widgets"><a class="header" href="#conditional-widgets">Conditional widgets</a></h3>
<p>The <code>view</code> macro allows you to include <code>if</code> and <code>match</code> statements for conditionally showing widgets.</p>
<p>Internally, the macro will use a <code>gtk::Stack</code>, so you can also use different <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/enum.StackTransitionType.html">transition types</a>.</p>
<pre><code class="language-rust ignore">if model.value % 2 == 0 {
    gtk::Label {
        set_label: "The value is even",
    },
    gtk::Label {
        set_label: "The value is odd",
    }
}</code></pre>
<pre><code class="language-rust ignore">// Use a transition type to set an animation when the visible widget changes
#[transition = "SlideRight"]
match model.value {
    0..=9 =&gt; {
        gtk::Label {
            set_label: "The value is below 10",
        },
    }
    _ =&gt; {
        gtk::Label {
            set_label: "The value is equal or above 10",
        },
    }
}</code></pre>
<p>If your conditional widget uses a <code>match</code> statement over an enum, you can destructure the enum in the <code>match</code> arms to access its variables with the help of the <code>#[track]</code> or <code>#[watch]</code> macros:</p>
<pre><code class="language-rust ignore">enum Foo {
    Bar(f32),
    Baz(String),
}

struct FooView {
    foo: Foo
}

impl Component for FooView {
    type Init = Foo;

    // snip

    view! {
        #[root]
        gtk::Box {
            append = match &amp;model.foo {
                Foo::Bar(num_value) =&gt; {
                    gtk::SpinButton {
                        // adding the `watch` macro lets you reference the destructured variables
                        #[watch]
                        set_value: num_value
                    }
                }
                Foo::Baz(str_value) =&gt; {
                    gtk::Label {
                        #[watch]
                        set_text: &amp;str_value
                    }
                }
            }
        }
    }

    // snip
}</code></pre>
<p>Please note: if you attempt to destructure in the normal way - without the <code>track</code> or <code>watch</code> macros - you will get a compilation error, and Rust will 'fail to see' the destructured variables at the point where your code uses them. This is due to limitations in Relm4's component initialization strategy. Please ensure that you use one of those macros to avoid this.</p>
<h3 id="returned-widgets"><a class="header" href="#returned-widgets">Returned widgets</a></h3>
<p>Sometimes, methods used for assigning widgets return another widget.
For example, <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/struct.Stack.html#method.add_child"><code>gtk::Stack::add_child()</code></a> allows you to add a widget to the stack, but also returns a <code>gtk::StackPage</code> widget.
To get access to this widget, you can use a special syntax of the view macro:</p>
<pre><code class="language-rust ignore">gtk::Stack {
    add_child = &amp;gtk::Label {
        set_label: "placeholder",
    } -&gt; {
        // Access the returned widgets (in this case gtk::StackPage)
        set_title: "page title",
    }
}</code></pre>
<h2 id="properties-2"><a class="header" href="#properties-2">Properties</a></h2>
<p>Properties are initialized and mutated by calling methods within the widget types.
Check the documentation for each widget type to see what methods are available.
Generally properties are set via setter methods, but any methods on the widget can also be called.
Many of these methods are part of an extension trait associated with the widget type.
These traits must be in scope to call their methods.
For example, if you want to use the <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/prelude/trait.GtkWindowExt.html#tymethod.set_default_width"><code>set_default_width</code></a> method from the <code>GtkWindowExt</code> trait, you must import the trait directly or glob import it from the prelude (<code>use gtk::prelude::*;</code>).</p>
<p>To initialize a property with a value:</p>
<pre><code class="language-rust ignore">set_property_name: value,</code></pre>
<p>Initialize a property only if its value is <code>Some</code>, and do nothing if it's <code>None</code>:</p>
<pre><code class="language-rust ignore">set_property_name?: value,</code></pre>
<p>Call a method that has multiple arguments:</p>
<pre><code class="language-rust ignore">set_property_name: (value1, value2, ...),</code></pre>
<p>Initialize and automatically update a property.</p>
<pre><code class="language-rust ignore">#[watch]
set_property_name: (value1, value2, ...),</code></pre>
<p>Initialize and automatically update a property with a tracker.
The <code>track_expression</code> can be any expression that returns a <code>bool</code>.
If it's true, it indicates that the method should be called:</p>
<pre><code class="language-rust ignore">#[track(track_expression)]
set_property_name: (value1, value2, ...),</code></pre>
<p>Initialize a property by iterating over an iterator.
You can use this for repeated calls to setter functions, like <code>add_class_name</code> in case you have multiple class names in a <code>Vec</code>.</p>
<pre><code class="language-rust ignore">#[iterate]
set_property_name: iterator,</code></pre>
<h3 id="trait-disambiguation"><a class="header" href="#trait-disambiguation">Trait disambiguation</a></h3>
<p>It is possible that several traits implement the same method for a type.
If both traits are in scope and you want to use the duplicated method name, you need to tell Rust which trait it should use.
To specify the intended trait, use the <code>TraitName::method</code> syntax, similar to <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Rust's fully qualified syntax for trait disambiguation</a>.</p>
<p>You can also use the full path of the trait if desired.</p>
<h2 id="signals-1"><a class="header" href="#signals-1">Signals</a></h2>
<p>When connecting signals emitted by widgets you can clone fields that you need in the closure (for example, the component sender) by listing the corresponding fields in square brackets.</p>
<pre><code class="language-rust ignore">connect_name[cloned_var1, cloned_var2, ...] =&gt; move |arg1, arg2, ...| { ... }</code></pre>
<h3 id="blocking-signals-temporarily"><a class="header" href="#blocking-signals-temporarily">Blocking signals temporarily</a></h3>
<p>Some signals are not only emitted after a user interaction, but also when you change values though your code, for example by using <code>#[watch]</code>.
This might not be the desired behavior and can even cause your application to freeze under certain circumstances.</p>
<p>To avoid this, you can name signal handlers by using an <code>@</code> and a name after the signal closure.
Then, you can use the signal handler name in the <code>#[block_signal(handler_name)]</code> attribute to deactivate the signal handler while you edit a value.</p>
<pre><code class="language-rust ignore">                gtk::ToggleButton {
                    set_label: "Counter is even",
                    #[watch]
                    #[block_signal(toggle_handler)]
                    set_active: counter.value % 2 == 0,

                    connect_toggled[sender] =&gt; move |_| {
                        sender.input(AppMsg::Increment);
                    } @toggle_handler,
                },</code></pre>
<h2 id="manual-code"><a class="header" href="#manual-code">Manual code</a></h2>
<p>Sometimes the macro isn't flexible enough.
In this case, you can always use manual code that will not be modified by the macro.</p>
<p>Here's a list of all the options available.</p>
<pre><code class="language-rust ignore">#[relm4_macros::component]
impl SimpleComponent for App {
    // ...

    view! {
        // ...
    }

    additional_fields! {
        // ...
    }

    fn pre_view() {
        // ...
    }

    fn post_view() {
        // ...
    }
}</code></pre>
<h3 id="add-more-fields-to-your-widgets"><a class="header" href="#add-more-fields-to-your-widgets">Add more fields to your widgets</a></h3>
<p>The widgets struct is automatically generated by the macro, but you can also add fields manually.</p>
<pre><code class="language-rust ignore">additional_fields! {
    test: u8,
}</code></pre>
<p>Initialize the variable in the <code>init</code> function by naming a local variable like your custom field.</p>
<pre><code class="language-rust ignore">let test = 0;

let widgets = view_output!();</code></pre>
<h3 id="manual-view"><a class="header" href="#manual-view">Manual view</a></h3>
<p>You can also implement your own view logic, which will be added to the view code that the macro generates.
Code inside <code>pre_view()</code> will run before the code of the macro, and <code>post_view()</code> will run after it.</p>
<blockquote>
<p>Code inside these "functions" isn't like a normal function!
The macro disallows returning early in <code>pre_view</code> to ensure that the code of the macro will always be executed.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro-expansion"><a class="header" href="#macro-expansion">Macro expansion</a></h1>
<p>To better understand the <code>component</code> macro, we will examine how the different parts of the macro are translated into real Rust code (aka the macro expansion). Therefore, we will write a small app that uses as many component macro features as possible.</p>
<h2 id="the-boilerplate"><a class="header" href="#the-boilerplate">The boilerplate</a></h2>
<p>First, let's have a look at the parts of the code that are later used by the macro.</p>
<h3 id="the-model-6"><a class="header" href="#the-model-6">The model</a></h3>
<p>The model simply stores a counter.</p>
<pre><code class="language-rust ignore">#[tracker::track]
struct AppModel {
    value: u8,
}</code></pre>
<h3 id="the-message-type"><a class="header" href="#the-message-type">The message type</a></h3>
<p>The message type is the same as in our first app. It includes a message to
increment and decrement the counter.</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
enum AppMsg {
    Increment,
    Decrement,
}</code></pre>
<h2 id="the-macro"><a class="header" href="#the-macro">The macro</a></h2>
<p>Before we break it down into smaller parts, let's take a look at the macro as a whole. If you're unfamiliar with the macro syntax, check out the previous chapter. There's a lot here, but that's because the macro supports a lot of functions!</p>
<pre><code class="language-rust ignore">#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = AppInit;
    type Input = AppMsg;
    type Output = ();

    view! {
        #[root]
        #[name(main_window)]
        gtk::Window {
            set_title: Some("Macro reference example"),
            set_default_width: 300,
            set_default_height: 100,

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,
                set_spacing: 5,
                set_margin_all: 5,

                append: inc_button = &amp;gtk::Button {
                    set_label: "Increment",
                    // Only set this if `icon_name` is Some
                    set_icon_name?: icon_name,
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Increment);
                    }
                },

                gtk::Button {
                    set_label: "Decrement",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Decrement);
                    }
                },

                gtk::Grid {
                    attach[1, 1, 1, 1] = &amp;gtk::Label {
                        // Alternative: #[track = "counter.value % 10 == 0"]
                        #[track(counter.value % 10 == 0)]
                        set_label: &amp;format!("Grid works! ({})", counter.value),
                    }
                },

                // A conditional widget
                // Alternative: #[transition = "SlideLeft"]
                #[transition(SlideLeft)]
                append = if counter.value % 2 == 0 {
                    gtk::Label {
                        set_label: "Value is even",
                    }
                } else if counter.value % 3 == 0 {
                    gtk::Label {
                        set_label: "Value is dividable by 3",
                    }
                } else {
                    gtk::Label {
                        set_label: "Value is odd",
                    }
                },

                #[transition = "SlideRight"]
                append: match_stack = match counter.value {
                    (0..=2) =&gt; {
                        gtk::Label {
                            set_label: "Value is smaller than 3",
                        }
                    },
                    _ =&gt; {
                        gtk::Label {
                            set_label: "Value is higher than 2",
                        }
                    }
                },

                append = &amp;gtk::Label,

                gtk::Label::builder()
                    .label("Builder pattern works!")
                    .selectable(true)
                    .build(),

                gtk::Label::new(Some("Constructors work!")),

                /// Counter label
                gtk::Label {
                    #[watch]
                    set_label: &amp;format!("Counter: {}", counter.value),
                    #[track]
                    set_margin_all: counter.value.into(),
                },

                gtk::ToggleButton {
                    set_label: "Counter is even",
                    #[watch]
                    #[block_signal(toggle_handler)]
                    set_active: counter.value % 2 == 0,

                    connect_toggled[sender] =&gt; move |_| {
                        sender.input(AppMsg::Increment);
                    } @toggle_handler,
                },

                #[local]
                local_label -&gt; gtk::Label {
                    set_opacity: 0.7,
                },

                #[local_ref]
                local_ref_label -&gt; gtk::Label {
                    set_opacity: 0.7,
                    set_size_request: (40, 40),
                },
            }
        },
        gtk::Window {
            set_title: Some("Another window"),
            set_default_width: 300,
            set_default_height: 100,
            set_transient_for: Some(&amp;main_window),
            // Empty args
            hide: (),

            #[watch]
            set_visible: counter.value == 42,

            #[name = "my_label_name"]
            gtk::Label {
                set_label: "You made it to 42!",
            }
        }
    }

    additional_fields! {
        test_field: u8,
    }

    // Initialize the UI.
    fn init(
        init: Self::Init,
        renamed_root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let counter = AppModel {
            value: init.counter,
            tracker: 0,
        };

        let test_field = 0;

        // Set icon name randomly to Some("go-up-symbolic") or None
        let icon_name = rand::random::&lt;bool&gt;().then_some("go-up-symbolic");

        let local_label = gtk::Label::new(Some("local_label"));
        let local_ref_label_value = gtk::Label::new(Some("local_ref_label"));
        let local_ref_label = &amp;local_ref_label_value;
        // Insert the macro code generation here
        let widgets = view_output!();

        ComponentParts {
            model: counter,
            widgets,
        }
    }

    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        self.reset();
        match msg {
            AppMsg::Increment =&gt; {
                self.set_value(self.value.wrapping_add(1));
            }
            AppMsg::Decrement =&gt; {
                self.set_value(self.value.wrapping_sub(1));
            }
        }
    }
}</code></pre>
<h2 id="the-expansion"><a class="header" href="#the-expansion">The expansion</a></h2>
<p>The macro expansion is not supposed to be readable, so the code might look a bit ugly.</p>
<h3 id="the-widgets-struct"><a class="header" href="#the-widgets-struct">The widgets struct</a></h3>
<p>The fields of the widgets struct cover all widgets we created, plus the additional fields we added manually. Named fields like <code>main_window</code> and <code>inc_button</code> keep their names. Unnamed fields will get automatically generated names with an unique ID. You should never refer to unnamed fields in your code because their names might change. At the end, we can find the additional field called <code>test_field</code> that we added manually.</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
struct AppWidgets {
    #[allow(missing_docs)]
    main_window: gtk::Window,
    #[allow(missing_docs)]
    _gtk_box_14: gtk::Box,
    #[allow(missing_docs)]
    inc_button: gtk::Button,
    #[allow(missing_docs)]
    _gtk_button_0: gtk::Button,
    #[allow(missing_docs)]
    _gtk_grid_2: gtk::Grid,
    #[allow(missing_docs)]
    _gtk_label_1: gtk::Label,
    #[allow(missing_docs)]
    _conditional_widget_3: relm4::gtk::Stack,
    #[allow(missing_docs)]
    _gtk_label_4: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_5: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_6: gtk::Label,
    #[allow(missing_docs)]
    match_stack: relm4::gtk::Stack,
    #[allow(missing_docs)]
    _gtk_label_7: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_8: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_9: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_builder_10: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_new_11: gtk::Label,
    /// Counter label
    _gtk_label_12: gtk::Label,
    #[allow(missing_docs)]
    _gtk_togglebutton_13: gtk::ToggleButton,
    #[allow(missing_docs)]
    toggle_handler: relm4::gtk::glib::signal::SignalHandlerId,
    #[allow(missing_docs)]
    local_label: gtk::Label,
    #[allow(missing_docs)]
    local_ref_label: gtk::Label,
    #[allow(missing_docs)]
    _gtk_window_15: gtk::Window,
    #[allow(missing_docs)]
    my_label_name: gtk::Label,
    test_field: u8,
}</code></pre>
<h3 id="the-simplecomponent-trait-implementation"><a class="header" href="#the-simplecomponent-trait-implementation">The <code>SimpleComponent</code> trait implementation</a></h3>
<p>The next thing the macro does is generating the <code>SimpleComponent</code> trait implementation block.</p>
<p>The start of the implementation block is very similar to the implementation block we use in the macro. Most notably, the <code>Root</code> type is automatically inserted, as is the implementation of <code>init_root</code>. All attributes and comments you add to the widget macro before the <code>impl</code> block should be kept as well.</p>
<pre><code class="language-rust ignore">impl SimpleComponent for AppModel {
    type Init = AppInit;
    type Input = AppMsg;
    type Output = ();
    type Widgets = AppWidgets;
    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        self.reset();
        match msg {
            AppMsg::Increment =&gt; {
                self.set_value(self.value.wrapping_add(1));
            }
            AppMsg::Decrement =&gt; {
                self.set_value(self.value.wrapping_sub(1));
            }
        }
    }
    type Root = gtk::Window;
    fn init_root() -&gt; Self::Root {
        let main_window = gtk::Window::default();
        main_window
    }</code></pre>
<h4 id="initialization-before-the-view_output-entrypoint"><a class="header" href="#initialization-before-the-view_output-entrypoint">Initialization before the <code>view_output</code> entrypoint</a></h4>
<p>A large part of the code generated by the macro is dedicated to the initialization of the view. This code is "expanded" from the <code>view_output!()</code> entrypoint. First, let's find the code we wrote before the entry point:</p>
<pre><code class="language-rust ignore">    fn init(
        init: Self::Init,
        renamed_root: &amp;Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let counter = AppModel {
            value: init.counter,
            tracker: 0,
        };
        let test_field = 0;
        let icon_name = rand::random::&lt;bool&gt;().then(|| "go-up-symbolic");
        let local_label = gtk::Label::new(Some("local_label"));
        let local_ref_label_value = gtk::Label::new(Some("local_ref_label"));
        let local_ref_label = &amp;local_ref_label_value;</code></pre>
<p>Next, the macro initializes all widgets. Widgets defined by their type are initialized with their <code>Default</code> implementation. Any constructors or functions that are invoked manually are left unchanged in the output.</p>
<pre><code class="language-rust ignore">        let main_window = renamed_root.clone();
        let _gtk_box_14 = gtk::Box::default();
        let inc_button = gtk::Button::default();
        let _gtk_button_0 = gtk::Button::default();
        let _gtk_grid_2 = gtk::Grid::default();
        let _gtk_label_1 = gtk::Label::default();
        let _conditional_widget_3 = relm4::gtk::Stack::default();
        _conditional_widget_3
            .set_transition_type(relm4::gtk::StackTransitionType::SlideLeft);
        let _gtk_label_4 = gtk::Label::default();
        let _gtk_label_5 = gtk::Label::default();
        let _gtk_label_6 = gtk::Label::default();
        let match_stack = relm4::gtk::Stack::default();
        match_stack.set_transition_type(relm4::gtk::StackTransitionType::SlideRight);
        let _gtk_label_7 = gtk::Label::default();
        let _gtk_label_8 = gtk::Label::default();
        let _gtk_label_9 = gtk::Label::default();
        let _gtk_label_builder_10 = gtk::Label::builder()
            .label("Builder pattern works!")
            .selectable(true)
            .build();
        let _gtk_label_new_11 = gtk::Label::new(Some("Constructors work!"));
        let _gtk_label_12 = gtk::Label::default();
        let _gtk_togglebutton_13 = gtk::ToggleButton::default();
        let _gtk_window_15 = gtk::Window::default();
        let my_label_name = gtk::Label::default();</code></pre>
<h4 id="assigning-properties"><a class="header" href="#assigning-properties">Assigning properties</a></h4>
<p>Assigning properties looks pretty normal as well. In the middle we have an optional assignment that uses an <code>if let</code> statement to only assign properties that match <code>Some(data)</code>. In the macro we marked this line with a <code>?</code>.</p>
<pre><code class="language-rust ignore">        main_window.set_title(Some("Macro reference example"));
        main_window.set_default_width(300);
        main_window.set_default_height(100);
        relm4::RelmContainerExt::container_add(&amp;main_window, &amp;_gtk_box_14);
        _gtk_box_14.set_orientation(gtk::Orientation::Vertical);
        _gtk_box_14.set_spacing(5);
        _gtk_box_14.set_margin_all(5);
        _gtk_box_14.append(&amp;inc_button);
        inc_button.set_label("Increment");
        if let Some(__p_assign) = icon_name {
            inc_button.set_icon_name(__p_assign);
        }
        relm4::RelmContainerExt::container_add(&amp;_gtk_box_14, &amp;_gtk_button_0);
        _gtk_button_0.set_label("Decrement");
        relm4::RelmContainerExt::container_add(&amp;_gtk_box_14, &amp;_gtk_grid_2);
        _gtk_grid_2.attach(&amp;_gtk_label_1, 1, 1, 1, 1);
        _gtk_label_1
            .set_label(
                &amp;{
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &amp;["Grid works! (", ")"],
                            &amp;[::core::fmt::ArgumentV1::new_display(&amp;counter.value)],
                        ),
                    );
                    res
                },
            );
        _gtk_box_14.append(&amp;_conditional_widget_3);
        _conditional_widget_3.add_named(&amp;_gtk_label_4, Some("0"));
        _gtk_label_4.set_label("Value is even");
        _conditional_widget_3.add_named(&amp;_gtk_label_5, Some("1"));
        _gtk_label_5.set_label("Value is dividable by 3");
        _conditional_widget_3.add_named(&amp;_gtk_label_6, Some("2"));
        _gtk_label_6.set_label("Value is odd");
        _gtk_box_14.append(&amp;match_stack);
        match_stack.add_named(&amp;_gtk_label_7, Some("0"));
        _gtk_label_7.set_label("Value is smaller than 3");
        match_stack.add_named(&amp;_gtk_label_8, Some("1"));
        _gtk_label_8.set_label("Value is higher than 2");
        _gtk_box_14.append(&amp;_gtk_label_9);</code></pre>
<h4 id="events-1"><a class="header" href="#events-1">Events</a></h4>
<p>Now the macro generates the code for connecting events.</p>
<pre><code class="language-rust ignore">        {
            #[allow(clippy::redundant_clone)]
            #[allow(clippy::clone_on_copy)]
            let sender = sender.clone();
            inc_button
                .connect_clicked(move |_| {
                    sender.input(AppMsg::Increment);
                });
        }
        {
            #[allow(clippy::redundant_clone)]
            #[allow(clippy::clone_on_copy)]
            let sender = sender.clone();
            _gtk_button_0
                .connect_clicked(move |_| {
                    sender.input(AppMsg::Decrement);
                });
        }
        let toggle_handler = {
            #[allow(clippy::redundant_clone)]
            #[allow(clippy::clone_on_copy)]
            let sender = sender.clone();
            _gtk_togglebutton_13
                .connect_toggled(move |_| {
                    sender.input(AppMsg::Increment);
                })
        };</code></pre>
<p>The code looks very similar to what we wrote in the macro.</p>
<pre><code class="language-rust ignore">                append: inc_button = &amp;gtk::Button {
                    set_label: "Increment",
                    // Only set this if `icon_name` is Some
                    set_icon_name?: icon_name,
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Increment);
                    }
                },

                gtk::Button {
                    set_label: "Decrement",
                    connect_clicked[sender] =&gt; move |_| {
                        sender.input(AppMsg::Decrement);
                    }
                },</code></pre>
<p>Most notably, the sender we put in the square brackets is cloned as we requested.</p>
<h4 id="initialization-after-the-view_output-entrypoint"><a class="header" href="#initialization-after-the-view_output-entrypoint">Initialization after the <code>view_output</code> entrypoint</a></h4>
<p>At the end we find the construction of the widgets struct and the construction of the <code>ComponentParts</code>, which was after the <code>view_output!</code> entrypoint.</p>
<pre><code class="language-rust ignore">        let widgets = Self::Widgets {
            main_window,
            _gtk_box_14,
            inc_button,
            _gtk_button_0,
            _gtk_grid_2,
            _gtk_label_1,
            _conditional_widget_3,
            _gtk_label_4,
            _gtk_label_5,
            _gtk_label_6,
            match_stack,
            _gtk_label_7,
            _gtk_label_8,
            _gtk_label_9,
            _gtk_label_builder_10,
            _gtk_label_new_11,
            _gtk_label_12,
            _gtk_togglebutton_13,
            toggle_handler,
            local_label,
            local_ref_label: local_ref_label.clone(),
            _gtk_window_15,
            my_label_name,
            test_field,
        };
        ComponentParts {
            model: counter,
            widgets,
        }</code></pre>
<h4 id="ui-updates-1"><a class="header" href="#ui-updates-1">UI updates</a></h4>
<p>The last step of the macro is to generate the update logic within the <code>update_view</code> function. Any code present in the <code>pre_view</code> and <code>post_view</code> "functions" will be expanded before or after the generated code. Note that the generated code returns a private struct to prevent early returns in <code>pre_view</code> from skipping the rest of the view update code.</p>
<pre><code class="language-rust ignore">    /// Update the view to represent the updated model.
    fn update_view(&amp;self, widgets: &amp;mut Self::Widgets, sender: ComponentSender&lt;Self&gt;) {
        struct __DoNotReturnManually;
        let _no_manual_return: __DoNotReturnManually = (move || {
            #[allow(unused_variables)]
            let Self::Widgets {
                main_window,
                _gtk_box_14,
                inc_button,
                _gtk_button_0,
                _gtk_grid_2,
                _gtk_label_1,
                _conditional_widget_3,
                _gtk_label_4,
                _gtk_label_5,
                _gtk_label_6,
                match_stack,
                _gtk_label_7,
                _gtk_label_8,
                _gtk_label_9,
                _gtk_label_builder_10,
                _gtk_label_new_11,
                _gtk_label_12,
                _gtk_togglebutton_13,
                toggle_handler,
                local_label,
                local_ref_label,
                _gtk_window_15,
                my_label_name,
                test_field,
            } = widgets;
            #[allow(unused_variables)]
            let counter = self;
            if (counter.value % 10 == 0) {
                _gtk_label_1
                    .set_label(
                        &amp;{
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &amp;["Grid works! (", ")"],
                                    &amp;[::core::fmt::ArgumentV1::new_display(&amp;counter.value)],
                                ),
                            );
                            res
                        },
                    );
            }
            let __current_page = _conditional_widget_3
                .visible_child_name()
                .map_or("".to_string(), |s| s.as_str().to_string());
            _conditional_widget_3
                .set_visible_child_name(
                    if counter.value % 2 == 0 {
                        let __page_active: bool = (__current_page == "0");
                        "0"
                    } else if counter.value % 3 == 0 {
                        let __page_active: bool = (__current_page == "1");
                        "1"
                    } else {
                        let __page_active: bool = (__current_page == "2");
                        "2"
                    },
                );
            let __current_page = match_stack
                .visible_child_name()
                .map_or("".to_string(), |s| s.as_str().to_string());
            match_stack
                .set_visible_child_name(
                    match counter.value {
                        (0..=2) =&gt; {
                            let __page_active: bool = (__current_page == "0");
                            "0"
                        }
                        _ =&gt; {
                            let __page_active: bool = (__current_page == "1");
                            "1"
                        }
                    },
                );
            _gtk_label_12
                .set_label(
                    &amp;{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &amp;["Counter: "],
                                &amp;[::core::fmt::ArgumentV1::new_display(&amp;counter.value)],
                            ),
                        );
                        res
                    },
                );
            if (counter.changed(Self::value())) {
                _gtk_label_12.set_margin_all(counter.value.into());
            }
            {
                use relm4::WidgetRef;
                #[allow(clippy::needless_borrow)]
                relm4::gtk::prelude::ObjectExt::block_signal(
                    _gtk_togglebutton_13.widget_ref(),
                    &amp;toggle_handler,
                );
            }
            _gtk_togglebutton_13.set_active(counter.value % 2 == 0);
            {
                use relm4::WidgetRef;
                #[allow(clippy::needless_borrow)]
                relm4::gtk::prelude::ObjectExt::unblock_signal(
                    _gtk_togglebutton_13.widget_ref(),
                    &amp;toggle_handler,
                );
            }
            _gtk_window_15.set_visible(counter.value == 42);
            (move || {})();
            __DoNotReturnManually
        })();
    }</code></pre>
<h4 id="generated-ui-updates"><a class="header" href="#generated-ui-updates">Generated UI updates</a></h4>
<p>Within the generated update logic, the macro generates its own code to support more efficient updates.</p>
<p>Updates from the <code>#[watch]</code> attribute are unconditional.</p>
<pre><code class="language-rust ignore">            _gtk_label_12
                .set_label(
                    &amp;{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &amp;["Counter: "],
                                &amp;[::core::fmt::ArgumentV1::new_display(&amp;counter.value)],
                            ),
                        );
                        res
                    },
                );</code></pre>
<p>Updates from expressions annotated with <code>#[track]</code> are conditional based on whether the value changed, or based on if an expression is a certain value.</p>
<pre><code class="language-rust ignore">            if (counter.changed(Self::value())) {
                _gtk_label_12.set_margin_all(counter.value.into());
            }</code></pre>
<pre><code class="language-rust ignore">            _conditional_widget_3
                .set_visible_child_name(
                    if counter.value % 2 == 0 {
                        let __page_active: bool = (__current_page == "0");
                        "0"
                    } else if counter.value % 3 == 0 {
                        let __page_active: bool = (__current_page == "1");
                        "1"
                    } else {
                        let __page_active: bool = (__current_page == "2");
                        "2"
                    },
                );</code></pre>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>Congrats for making it this far 🎉! You're now a real expert of Relm4!</p>
<p>As you have seen, the macro is nothing magical. It simply works with the information you give it.</p>
<h2 id="the-whole-macro-expansion"><a class="header" href="#the-whole-macro-expansion">The whole macro expansion</a></h2>
<p>If you want to look at the whole macro expansion at once, here it is.</p>
<pre><code class="language-rust ignore">#![feature(prelude_import)]
//! This example is a modified version of the `macro_reference` example in the [main Relm4
//! repository][Relm4 repo].
//!
//! [Relm4 repo]: https://github.com/Relm4/Relm4/blob/main/examples/macro_reference.rs
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use gtk::prelude::{
    BoxExt, ButtonExt, GridExt, GtkWindowExt, OrientableExt, ToggleButtonExt, WidgetExt,
};
use relm4::{gtk, ComponentParts, ComponentSender, RelmApp, SimpleComponent, WidgetPlus};
struct AppModel {
    value: u8,
    tracker: u8,
}
impl AppModel {
    #[allow(dead_code, non_snake_case)]
    /// Get an immutable reference to this field.
    fn get_value(&amp;self) -&gt; &amp;u8 {
        &amp;self.value
    }
    #[allow(dead_code, non_snake_case)]
    /// Get a mutable reference to this field. Marks the field as changed.
    fn get_mut_value(&amp;mut self) -&gt; &amp;mut u8 {
        self.tracker |= Self::value();
        &amp;mut self.value
    }
    #[allow(dead_code, non_snake_case)]
    /// Use a closure to update this field. Marks the field as changed.
    fn update_value&lt;F: Fn(&amp;mut u8)&gt;(&amp;mut self, f: F) {
        self.tracker |= Self::value();
        f(&amp;mut self.value);
    }
    #[allow(dead_code, non_snake_case)]
    /// Get bit mask to look for changes on this field.
    fn value() -&gt; u8 {
        1 &lt;&lt; 0usize
    }
    #[allow(dead_code, non_snake_case)]
    /// Setter method. Will mark field as changed.
    fn set_value(&amp;mut self, value: u8) {
        if self.value != value {
            self.tracker |= Self::value();
        }
        self.value = value;
    }
    #[allow(dead_code)]
    /// Use this to check whether any changes made to this struct.
    fn track_all() -&gt; u8 {
        u8::MAX
    }
    #[allow(dead_code)]
    /// Use this to mark all fields of the struct as changed.
    fn mark_all_changed(&amp;mut self) {
        self.tracker = u8::MAX;
    }
    /// Check for changes made to this struct.
    fn changed(&amp;self, mask: u8) -&gt; bool {
        self.tracker &amp; mask != 0
    }
    /// Resets the tracker of this struct.
    fn reset(&amp;mut self) {
        self.tracker = 0;
    }
}
enum AppMsg {
    Increment,
    Decrement,
}
#[automatically_derived]
impl ::core::fmt::Debug for AppMsg {
    fn fmt(&amp;self, f: &amp;mut ::core::fmt::Formatter) -&gt; ::core::fmt::Result {
        match self {
            AppMsg::Increment =&gt; ::core::fmt::Formatter::write_str(f, "Increment"),
            AppMsg::Decrement =&gt; ::core::fmt::Formatter::write_str(f, "Decrement"),
        }
    }
}
struct AppInit {
    counter: u8,
}
#[allow(dead_code)]
struct AppWidgets {
    #[allow(missing_docs)]
    main_window: gtk::Window,
    #[allow(missing_docs)]
    _gtk_box_14: gtk::Box,
    #[allow(missing_docs)]
    inc_button: gtk::Button,
    #[allow(missing_docs)]
    _gtk_button_0: gtk::Button,
    #[allow(missing_docs)]
    _gtk_grid_2: gtk::Grid,
    #[allow(missing_docs)]
    _gtk_label_1: gtk::Label,
    #[allow(missing_docs)]
    _conditional_widget_3: relm4::gtk::Stack,
    #[allow(missing_docs)]
    _gtk_label_4: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_5: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_6: gtk::Label,
    #[allow(missing_docs)]
    match_stack: relm4::gtk::Stack,
    #[allow(missing_docs)]
    _gtk_label_7: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_8: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_9: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_builder_10: gtk::Label,
    #[allow(missing_docs)]
    _gtk_label_new_11: gtk::Label,
    /// Counter label
    _gtk_label_12: gtk::Label,
    #[allow(missing_docs)]
    _gtk_togglebutton_13: gtk::ToggleButton,
    #[allow(missing_docs)]
    toggle_handler: relm4::gtk::glib::signal::SignalHandlerId,
    #[allow(missing_docs)]
    local_label: gtk::Label,
    #[allow(missing_docs)]
    local_ref_label: gtk::Label,
    #[allow(missing_docs)]
    _gtk_window_15: gtk::Window,
    #[allow(missing_docs)]
    my_label_name: gtk::Label,
    test_field: u8,
}
#[automatically_derived]
#[allow(dead_code)]
impl ::core::fmt::Debug for AppWidgets {
    fn fmt(&amp;self, f: &amp;mut ::core::fmt::Formatter) -&gt; ::core::fmt::Result {
        let names: &amp;'static _ = &amp;[
            "main_window",
            "_gtk_box_14",
            "inc_button",
            "_gtk_button_0",
            "_gtk_grid_2",
            "_gtk_label_1",
            "_conditional_widget_3",
            "_gtk_label_4",
            "_gtk_label_5",
            "_gtk_label_6",
            "match_stack",
            "_gtk_label_7",
            "_gtk_label_8",
            "_gtk_label_9",
            "_gtk_label_builder_10",
            "_gtk_label_new_11",
            "_gtk_label_12",
            "_gtk_togglebutton_13",
            "toggle_handler",
            "local_label",
            "local_ref_label",
            "_gtk_window_15",
            "my_label_name",
            "test_field",
        ];
        let values: &amp;[&amp;dyn ::core::fmt::Debug] = &amp;[
            &amp;&amp;self.main_window,
            &amp;&amp;self._gtk_box_14,
            &amp;&amp;self.inc_button,
            &amp;&amp;self._gtk_button_0,
            &amp;&amp;self._gtk_grid_2,
            &amp;&amp;self._gtk_label_1,
            &amp;&amp;self._conditional_widget_3,
            &amp;&amp;self._gtk_label_4,
            &amp;&amp;self._gtk_label_5,
            &amp;&amp;self._gtk_label_6,
            &amp;&amp;self.match_stack,
            &amp;&amp;self._gtk_label_7,
            &amp;&amp;self._gtk_label_8,
            &amp;&amp;self._gtk_label_9,
            &amp;&amp;self._gtk_label_builder_10,
            &amp;&amp;self._gtk_label_new_11,
            &amp;&amp;self._gtk_label_12,
            &amp;&amp;self._gtk_togglebutton_13,
            &amp;&amp;self.toggle_handler,
            &amp;&amp;self.local_label,
            &amp;&amp;self.local_ref_label,
            &amp;&amp;self._gtk_window_15,
            &amp;&amp;self.my_label_name,
            &amp;&amp;self.test_field,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "AppWidgets",
            names,
            values,
        )
    }
}
impl SimpleComponent for AppModel {
    type Init = AppInit;
    type Input = AppMsg;
    type Output = ();
    type Widgets = AppWidgets;
    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        self.reset();
        match msg {
            AppMsg::Increment =&gt; {
                self.set_value(self.value.wrapping_add(1));
            }
            AppMsg::Decrement =&gt; {
                self.set_value(self.value.wrapping_sub(1));
            }
        }
    }
    type Root = gtk::Window;
    fn init_root() -&gt; Self::Root {
        let main_window = gtk::Window::default();
        main_window
    }
    /// Update the view to represent the updated model.
    fn update_view(&amp;self, widgets: &amp;mut Self::Widgets, sender: ComponentSender&lt;Self&gt;) {
        struct __DoNotReturnManually;
        let _no_manual_return: __DoNotReturnManually = (move || {
            #[allow(unused_variables)]
            let Self::Widgets {
                main_window,
                _gtk_box_14,
                inc_button,
                _gtk_button_0,
                _gtk_grid_2,
                _gtk_label_1,
                _conditional_widget_3,
                _gtk_label_4,
                _gtk_label_5,
                _gtk_label_6,
                match_stack,
                _gtk_label_7,
                _gtk_label_8,
                _gtk_label_9,
                _gtk_label_builder_10,
                _gtk_label_new_11,
                _gtk_label_12,
                _gtk_togglebutton_13,
                toggle_handler,
                local_label,
                local_ref_label,
                _gtk_window_15,
                my_label_name,
                test_field,
            } = widgets;
            #[allow(unused_variables)]
            let counter = self;
            if (counter.value % 10 == 0) {
                _gtk_label_1
                    .set_label(
                        &amp;{
                            let res = ::alloc::fmt::format(
                                ::core::fmt::Arguments::new_v1(
                                    &amp;["Grid works! (", ")"],
                                    &amp;[::core::fmt::ArgumentV1::new_display(&amp;counter.value)],
                                ),
                            );
                            res
                        },
                    );
            }
            let __current_page = _conditional_widget_3
                .visible_child_name()
                .map_or("".to_string(), |s| s.as_str().to_string());
            _conditional_widget_3
                .set_visible_child_name(
                    if counter.value % 2 == 0 {
                        let __page_active: bool = (__current_page == "0");
                        "0"
                    } else if counter.value % 3 == 0 {
                        let __page_active: bool = (__current_page == "1");
                        "1"
                    } else {
                        let __page_active: bool = (__current_page == "2");
                        "2"
                    },
                );
            let __current_page = match_stack
                .visible_child_name()
                .map_or("".to_string(), |s| s.as_str().to_string());
            match_stack
                .set_visible_child_name(
                    match counter.value {
                        (0..=2) =&gt; {
                            let __page_active: bool = (__current_page == "0");
                            "0"
                        }
                        _ =&gt; {
                            let __page_active: bool = (__current_page == "1");
                            "1"
                        }
                    },
                );
            _gtk_label_12
                .set_label(
                    &amp;{
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &amp;["Counter: "],
                                &amp;[::core::fmt::ArgumentV1::new_display(&amp;counter.value)],
                            ),
                        );
                        res
                    },
                );
            if (counter.changed(Self::value())) {
                _gtk_label_12.set_margin_all(counter.value.into());
            }
            {
                use relm4::WidgetRef;
                #[allow(clippy::needless_borrow)]
                relm4::gtk::prelude::ObjectExt::block_signal(
                    _gtk_togglebutton_13.widget_ref(),
                    &amp;toggle_handler,
                );
            }
            _gtk_togglebutton_13.set_active(counter.value % 2 == 0);
            {
                use relm4::WidgetRef;
                #[allow(clippy::needless_borrow)]
                relm4::gtk::prelude::ObjectExt::unblock_signal(
                    _gtk_togglebutton_13.widget_ref(),
                    &amp;toggle_handler,
                );
            }
            _gtk_window_15.set_visible(counter.value == 42);
            (move || {})();
            __DoNotReturnManually
        })();
    }
    fn init(
        init: Self::Init,
        renamed_root: &amp;Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let counter = AppModel {
            value: init.counter,
            tracker: 0,
        };
        let test_field = 0;
        let icon_name = rand::random::&lt;bool&gt;().then(|| "go-up-symbolic");
        let local_label = gtk::Label::new(Some("local_label"));
        let local_ref_label_value = gtk::Label::new(Some("local_ref_label"));
        let local_ref_label = &amp;local_ref_label_value;
        let main_window = renamed_root.clone();
        let _gtk_box_14 = gtk::Box::default();
        let inc_button = gtk::Button::default();
        let _gtk_button_0 = gtk::Button::default();
        let _gtk_grid_2 = gtk::Grid::default();
        let _gtk_label_1 = gtk::Label::default();
        let _conditional_widget_3 = relm4::gtk::Stack::default();
        _conditional_widget_3
            .set_transition_type(relm4::gtk::StackTransitionType::SlideLeft);
        let _gtk_label_4 = gtk::Label::default();
        let _gtk_label_5 = gtk::Label::default();
        let _gtk_label_6 = gtk::Label::default();
        let match_stack = relm4::gtk::Stack::default();
        match_stack.set_transition_type(relm4::gtk::StackTransitionType::SlideRight);
        let _gtk_label_7 = gtk::Label::default();
        let _gtk_label_8 = gtk::Label::default();
        let _gtk_label_9 = gtk::Label::default();
        let _gtk_label_builder_10 = gtk::Label::builder()
            .label("Builder pattern works!")
            .selectable(true)
            .build();
        let _gtk_label_new_11 = gtk::Label::new(Some("Constructors work!"));
        let _gtk_label_12 = gtk::Label::default();
        let _gtk_togglebutton_13 = gtk::ToggleButton::default();
        let _gtk_window_15 = gtk::Window::default();
        let my_label_name = gtk::Label::default();
        {
            #[allow(clippy::redundant_clone)]
            #[allow(clippy::clone_on_copy)]
            let sender = sender.clone();
            inc_button
                .connect_clicked(move |_| {
                    sender.input(AppMsg::Increment);
                });
        }
        {
            #[allow(clippy::redundant_clone)]
            #[allow(clippy::clone_on_copy)]
            let sender = sender.clone();
            _gtk_button_0
                .connect_clicked(move |_| {
                    sender.input(AppMsg::Decrement);
                });
        }
        let toggle_handler = {
            #[allow(clippy::redundant_clone)]
            #[allow(clippy::clone_on_copy)]
            let sender = sender.clone();
            _gtk_togglebutton_13
                .connect_toggled(move |_| {
                    sender.input(AppMsg::Increment);
                })
        };
        {}
        main_window.set_title(Some("Macro reference example"));
        main_window.set_default_width(300);
        main_window.set_default_height(100);
        relm4::RelmContainerExt::container_add(&amp;main_window, &amp;_gtk_box_14);
        _gtk_box_14.set_orientation(gtk::Orientation::Vertical);
        _gtk_box_14.set_spacing(5);
        _gtk_box_14.set_margin_all(5);
        _gtk_box_14.append(&amp;inc_button);
        inc_button.set_label("Increment");
        if let Some(__p_assign) = icon_name {
            inc_button.set_icon_name(__p_assign);
        }
        relm4::RelmContainerExt::container_add(&amp;_gtk_box_14, &amp;_gtk_button_0);
        _gtk_button_0.set_label("Decrement");
        relm4::RelmContainerExt::container_add(&amp;_gtk_box_14, &amp;_gtk_grid_2);
        _gtk_grid_2.attach(&amp;_gtk_label_1, 1, 1, 1, 1);
        _gtk_label_1
            .set_label(
                &amp;{
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &amp;["Grid works! (", ")"],
                            &amp;[::core::fmt::ArgumentV1::new_display(&amp;counter.value)],
                        ),
                    );
                    res
                },
            );
        _gtk_box_14.append(&amp;_conditional_widget_3);
        _conditional_widget_3.add_named(&amp;_gtk_label_4, Some("0"));
        _gtk_label_4.set_label("Value is even");
        _conditional_widget_3.add_named(&amp;_gtk_label_5, Some("1"));
        _gtk_label_5.set_label("Value is dividable by 3");
        _conditional_widget_3.add_named(&amp;_gtk_label_6, Some("2"));
        _gtk_label_6.set_label("Value is odd");
        _gtk_box_14.append(&amp;match_stack);
        match_stack.add_named(&amp;_gtk_label_7, Some("0"));
        _gtk_label_7.set_label("Value is smaller than 3");
        match_stack.add_named(&amp;_gtk_label_8, Some("1"));
        _gtk_label_8.set_label("Value is higher than 2");
        _gtk_box_14.append(&amp;_gtk_label_9);
        relm4::RelmContainerExt::container_add(&amp;_gtk_box_14, &amp;_gtk_label_builder_10);
        relm4::RelmContainerExt::container_add(&amp;_gtk_box_14, &amp;_gtk_label_new_11);
        relm4::RelmContainerExt::container_add(&amp;_gtk_box_14, &amp;_gtk_label_12);
        _gtk_label_12
            .set_label(
                &amp;{
                    let res = ::alloc::fmt::format(
                        ::core::fmt::Arguments::new_v1(
                            &amp;["Counter: "],
                            &amp;[::core::fmt::ArgumentV1::new_display(&amp;counter.value)],
                        ),
                    );
                    res
                },
            );
        _gtk_label_12.set_margin_all(counter.value.into());
        relm4::RelmContainerExt::container_add(&amp;_gtk_box_14, &amp;_gtk_togglebutton_13);
        _gtk_togglebutton_13.set_label("Counter is even");
        {
            use relm4::WidgetRef;
            #[allow(clippy::needless_borrow)]
            relm4::gtk::prelude::ObjectExt::block_signal(
                _gtk_togglebutton_13.widget_ref(),
                &amp;toggle_handler,
            );
        }
        _gtk_togglebutton_13.set_active(counter.value % 2 == 0);
        {
            use relm4::WidgetRef;
            #[allow(clippy::needless_borrow)]
            relm4::gtk::prelude::ObjectExt::unblock_signal(
                _gtk_togglebutton_13.widget_ref(),
                &amp;toggle_handler,
            );
        }
        relm4::RelmContainerExt::container_add(&amp;_gtk_box_14, &amp;local_label);
        local_label.set_opacity(0.7);
        relm4::RelmContainerExt::container_add(&amp;_gtk_box_14, &amp;local_ref_label);
        local_ref_label.set_opacity(0.7);
        local_ref_label.set_size_request(40, 40);
        let __current_page = "";
        _conditional_widget_3
            .set_visible_child_name(
                if counter.value % 2 == 0 {
                    let __page_active: bool = (__current_page == "0");
                    "0"
                } else if counter.value % 3 == 0 {
                    let __page_active: bool = (__current_page == "1");
                    "1"
                } else {
                    let __page_active: bool = (__current_page == "2");
                    "2"
                },
            );
        let __current_page = "";
        match_stack
            .set_visible_child_name(
                match counter.value {
                    (0..=2) =&gt; "0",
                    _ =&gt; "1",
                },
            );
        _gtk_window_15.set_title(Some("Another window"));
        _gtk_window_15.set_default_width(300);
        _gtk_window_15.set_default_height(100);
        _gtk_window_15.set_transient_for(Some(&amp;main_window));
        _gtk_window_15.hide();
        _gtk_window_15.set_visible(counter.value == 42);
        relm4::RelmContainerExt::container_add(&amp;_gtk_window_15, &amp;my_label_name);
        my_label_name.set_label("You made it to 42!");
        let widgets = Self::Widgets {
            main_window,
            _gtk_box_14,
            inc_button,
            _gtk_button_0,
            _gtk_grid_2,
            _gtk_label_1,
            _conditional_widget_3,
            _gtk_label_4,
            _gtk_label_5,
            _gtk_label_6,
            match_stack,
            _gtk_label_7,
            _gtk_label_8,
            _gtk_label_9,
            _gtk_label_builder_10,
            _gtk_label_new_11,
            _gtk_label_12,
            _gtk_togglebutton_13,
            toggle_handler,
            local_label,
            local_ref_label: local_ref_label.clone(),
            _gtk_window_15,
            my_label_name,
            test_field,
        };
        ComponentParts {
            model: counter,
            widgets,
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guides"><a class="header" href="#migration-guides">Migration guides</a></h1>
<p>The sections of this chapter will help you to migrate your code from an older to newer version of Relm4.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-from-v02-to-v04"><a class="header" href="#migration-from-v02-to-v04">Migration from v0.2 to v0.4</a></h1>
<p>Fortunately, there aren't many big breaking changes in version 0.4 despite a lot of improvements under the hood.</p>
<blockquote>
<p>In case you're wondering what happened to version 0.3, Relm4 now tries to follow the version number of gtk4-rs and therefore skipped v0.3.</p>
</blockquote>
<h2 id="factoryprototype"><a class="header" href="#factoryprototype">FactoryPrototype</a></h2>
<p>The methods of <code>FactoryPrototype</code> were renamed to better match the rest of Relm4's traits.</p>
<ul>
<li><code>generate</code> =&gt; <code>init_view</code></li>
<li><code>update</code> =&gt; <code>view</code></li>
<li><code>get_root</code> =&gt; <code>root_widget</code></li>
</ul>
<h2 id="widget-macro"><a class="header" href="#widget-macro"><code>widget</code> macro</a></h2>
<ul>
<li><code>manual_view</code> was renamed to <code>post_view</code> and <code>pre_view</code> was added to run code before the macro generated code in the view function.</li>
<li><code>component!</code> was removed, components are now accessible without extra code.</li>
<li><code>parent!</code> was added to access the parent widgets which previously required no extra code.</li>
</ul>
<h2 id="components-2"><a class="header" href="#components-2">Components</a></h2>
<p>The <a href="https://docs.rs/relm4/latest/relm4/component/trait.Component.html"><code>Components</code></a> trait now has a new method called <code>connect_parent</code>.
This method doesn't do much more than passing the parent widgets down to individual components and originated unintentionally in the rework of the initialization process.
Because this method is usually just repetitive code, you can now use the derive macro instead:</p>
<pre><code class="language-rust ignore">#[derive(relm4::Components)]
struct AppComponents {
    header: RelmComponent&lt;HeaderModel, AppModel&gt;,
    dialog: RelmComponent&lt;DialogModel, AppModel&gt;,
}</code></pre>
<p>The derive macro will always use <code>RelmWorker::with_new_thread()</code> for workers.</p>
<p>Also, <code>RelmComponent::with_new_thread()</code> was removed due to the restructuring.
It's recommended to use workers or message handlers for blocking operations instead.</p>
<blockquote>
<p>If there's anything missing, let me know. You can simply open an issue on <a href="https://github.com/Relm4/Relm4">GitHub</a> or write a message in the <a href="https://matrix.to/#/#relm4:matrix.org">Matrix room</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-from-v04-to-v05"><a class="header" href="#migration-from-v04-to-v05">Migration from v0.4 to v0.5</a></h1>
<p>Version 0.5 brings many exciting changes but also a few major breaking changes.
In this chapter, all changes should be covered to help you migrating your existing code quickly.</p>
<h2 id="components-3"><a class="header" href="#components-3">Components</a></h2>
<p><code>Component</code> unifies several traits that existed before.
It entirely replaces <code>AppUpdate</code>, <code>ComponentUpdate</code>, <code>AsyncComponentUpdate</code>, <code>MessageHandler</code>, <code>MicroModel</code>, <code>MicroWidgets</code>, <code>Components</code> and <code>Widgets</code>.
Components are now more similar to <code>MicroComponent</code> which means they are much more flexible and don't need a typed connection to their parent component.
This makes using the same component with different parent components much easier.
Instead of accessing the parent model, you define <code>Init</code> as a type that includes all information to initialize the component.</p>
<p>The life cycle has changed a bit, too.</p>
<ol>
<li><a href="https://docs.rs/relm4/latest/relm4/component/trait.Component.html#tymethod.init_root">Initialization of the root widget</a>.
The reason behind this is to allow parent components to access the root widget before the rest of the component is initialized.</li>
<li><a href="https://docs.rs/relm4/latest/relm4/component/trait.Component.html#tymethod.init">Initialize the component itself and the widgets</a>.
This happens in one method now, which makes it easier especially for more difficult initializations.</li>
<li>Regarding updates, there hasn't been a lot of changes. However you can now optionally update view and model at once using <a href="https://docs.rs/relm4/latest/relm4/component/trait.Component.html#method.update_with_view"><code>update_with_view</code></a>.</li>
<li>The <a href="https://docs.rs/relm4/latest/relm4/component/trait.Component.html#method.shutdown">shutdown</a> method is called when the component is destroyed. Components don't have to live for the entire application lifespan anymore.</li>
</ol>
<h3 id="senders-and-messages"><a class="header" href="#senders-and-messages">Senders and messages</a></h3>
<p>Components have three kinds of messages now:</p>
<ol>
<li><code>Input</code> is the regular <code>Msg</code> type from the <code>Model</code> trait in 0.4.</li>
<li><code>Output</code> is the message type, that can be used to forward information to other components automatically (or <code>()</code> if you don't care about forwarding).
You will find more information about initializing components in the next section.</li>
<li><code>CmdOutput</code> is the output of commands.
Commands are futures that are executed in the background.
<strong>They fully replace async workers.</strong>
The result of this future is the <code>CmdOutput</code> message handled in <a href="https://docs.rs/relm4/latest/relm4/component/trait.Component.html#method.update_cmd"><code>update_cmd</code></a>, similar to the regular update function.</li>
</ol>
<p>The <code>send!</code> macro is obsolete. Please use <code>sender.input(msg)</code> instead.</p>
<h3 id="initializing-components"><a class="header" href="#initializing-components">Initializing components</a></h3>
<p>Components are initialized in the <a href="https://docs.rs/relm4/latest/relm4/component/trait.Component.html#tymethod.init">init</a> method of their parent.
You simply call <code>MyComponentType::builder()</code> to get a <a href="https://docs.rs/relm4/latest/relm4/component/struct.ComponentBuilder.html"><code>ComponentBuilder</code></a>.
Then you launch the component by calling <code>builder.launch(init_params)</code> to receive a <a href="https://docs.rs/relm4/latest/relm4/component/struct.Connector.html"><code>Connector</code></a>.
From the connector you can decide to automatically forward messages to another component or just <a href="https://docs.rs/relm4/latest/relm4/component/struct.Connector.html#method.detach">detach</a> the connector to get a <a href="https://docs.rs/relm4/latest/relm4/component/struct.Controller.html"><code>Controller</code></a>.
The <strong>controller</strong> is the type you now <strong>store in the model of the parent component</strong> instead of creating a separate components struct.
There's no <code>Components</code> trait necessary.</p>
<p>For types that implement <code>Component</code> that don't have any widgets (such as implementers of the <a href="https://docs.rs/relm4/latest/relm4/component/worker/trait.Worker.html"><code>Worker</code></a> trait), you can call <a href="https://docs.rs/relm4/latest/relm4/component/struct.ComponentBuilder.html#method.detach_worker"><code>detach_worker</code></a> from a <code>ComponentBuilder</code>.
This spawns the internal runtime on a separate thread and gives you a <a href="https://docs.rs/relm4/latest/relm4/component/worker/struct.WorkerController.html"><code>WorkerController</code></a>.</p>
<h3 id="helper-traits"><a class="header" href="#helper-traits">Helper traits</a></h3>
<h4 id="simplecomponent"><a class="header" href="#simplecomponent"><code>SimpleComponent</code></a></h4>
<p><code>SimpleComponent</code> is a simpler variant of <code>Component</code> that helps with the implementation of <code>Component</code>.
Particularly, it doesn't support commands.</p>
<h4 id="worker"><a class="header" href="#worker"><code>Worker</code></a></h4>
<p><code>Worker</code> is an even simpler variant of <code>SimpleComponent</code> that helps with the implementation of <code>Component</code>.
Particularly, it doesn't support widgets and allows running the components update loop on a different thread by using <a href="https://docs.rs/relm4/latest/relm4/component/struct.ComponentBuilder.html#method.detach_worker"><code>detach_worker</code></a>.
<strong>This is the replacement for the previously separated <code>RelmWorker</code> type.</strong></p>
<h2 id="factories"><a class="header" href="#factories">Factories</a></h2>
<p>Factories now work very similar to components.
In fact, the new <a href="https://docs.rs/relm4/latest/relm4/factory/trait.FactoryComponent.html"><code>FactoryComponent</code></a> trait that replaces <code>FactoryPrototype</code> is almost identical to the <code>Component</code> trait.
Messages can now be optionally passed by using the <a href="https://docs.rs/relm4/latest/relm4/factory/trait.FactoryComponent.html#method.forward_to_parent"><code>forward_to_parent</code></a> method.</p>
<p><code>FactoryVec</code> was entirely removed in favor of <code>FactoryVecDeque</code>.
Edits to factories are now similar to <code>Mutex</code> and require a guard.
When the guard is dropped, all changes are rendered automatically, so no render method is required anymore.</p>
<h2 id="the-view-macro-1"><a class="header" href="#the-view-macro-1">The <code>view</code> macro</a></h2>
<ul>
<li>In general, a lot of internal macros were moved to be just attributes like <code>watch!</code> and <code>track!</code> now written as <code>#[watch]</code> and <code>#[track(optional_condition)]</code>.</li>
<li>Multiple arguments now don't need <code>args!()</code> but just <code>()</code> whereas tuples need two parenthesis <code>(())</code>.</li>
<li>Wrapping widgets into <code>Some</code> is now also an attribute <code>#[wrap(Some)]</code>.</li>
<li>Additional arguments are now passed with square brackets <code>[]</code> instead of parenthesis <code>()</code>.</li>
<li>Cloning variables for closures is always done with square brackets <code>[]</code> instead of parenthesis <code>()</code>.</li>
</ul>
<table>
<tr>
<th> Old </th>
<th> New </th>
</tr>
<tr>
<td>
<pre><code class="language-rust ignore">view! {
    gtk::HeaderBar {
        set_title_widget = Some(&amp;gtk::Box) {
            append: group = &amp;gtk::ToggleButton {
                set_label: watch!(model.label),

                connect_toggled(sender) =&gt; move |btn| {
                    // ...
                },
            },
        }
    }
}</code></pre>
</td>
<td>
<pre><code class="language-rust ignore">view! {
    gtk::HeaderBar {
        #[wrap(Some)]
        set_title_widget = &amp;gtk::Box {
            append: group = &amp;gtk::ToggleButton {
                #[watch]
                set_label: model.label,

                connect_toggled[sender] =&gt; move |btn| {
                    // ...
                },
            },
        }
    }
}</code></pre>
</td>
</tr>
</table>
<h3 id="the-widget-macro"><a class="header" href="#the-widget-macro">The <code>widget</code> macro</a></h3>
<ul>
<li>The macro in now called <code>#[component]</code>.</li>
<li>You need to use <code>let widgets = view_output!();</code> in the <code>init</code> function to inject the code from the <code>view</code> macro.</li>
<li><code>pre_init</code> -&gt; Code before <code>view_output!()</code>.</li>
<li><code>post_init</code> -&gt; Code after <code>view_output!()</code>.</li>
</ul>
<h2 id="relmapp"><a class="header" href="#relmapp">RelmApp</a></h2>
<p>Now you need to specify an application id and a generic parameter is required when calling <code>run()</code>.</p>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<ul>
<li><code>WidgetPlus::inline_css</code> now takes <code>&amp;str</code> as parameter instead of <code>&amp;[u8]</code>.</li>
</ul>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>v0.4</th><th>v0.5</th></tr></thead><tbody>
<tr><td><code>Model</code></td><td><code>Component</code></td></tr>
<tr><td><code>AppUpdate</code></td><td><code>Component</code></td></tr>
<tr><td><code>ComponentUpdate</code></td><td><code>Component</code></td></tr>
<tr><td><code>AsyncComponentUpdate</code></td><td><code>Component</code></td></tr>
<tr><td><code>MicroComponent</code></td><td><code>Component</code></td></tr>
<tr><td><code>MicroWidgets</code></td><td><code>Component</code></td></tr>
<tr><td><code>MessageHandler</code></td><td><code>Component</code></td></tr>
<tr><td><code>FactoryPrototype</code></td><td><code>FactoryComponent</code></td></tr>
<tr><td><code>Model::Msg</code></td><td><code>Component::Input</code></td></tr>
<tr><td><code>Model::Widgets</code></td><td><code>Component::Widgets</code></td></tr>
<tr><td><code>Model::Components</code></td><td>removed</td></tr>
<tr><td><code>Components</code></td><td>Store a <code>Controller</code> for each component in your model</td></tr>
<tr><td><code>parent_sender</code></td><td>Forward output messages from one component to another by using <code>Connector</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p>In case there's something missing, please let me know. You can simply open an issue on <a href="https://github.com/Relm4/Relm4">GitHub</a> or write a message in the <a href="https://matrix.to/#/#relm4:matrix.org">Matrix room</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-from-v05-to-v06"><a class="header" href="#migration-from-v05-to-v06">Migration from v0.5 to v0.6</a></h1>
<h2 id="renamed-methods"><a class="header" href="#renamed-methods">Renamed methods</a></h2>
<ul>
<li><code>FactoryComponent::output_to_parent_input()</code> =&gt; <code>FactoryComponent::forward_to_parent()</code></li>
</ul>
<h2 id="actions"><a class="header" href="#actions">Actions</a></h2>
<ul>
<li><a href="https://docs.rs/relm4/latest/relm4/actions/struct.RelmActionGroup.html#method.add_action"><code>RelmActionGroup::add_action()</code></a> now consumes the action</li>
<li>Use <a href="https://docs.rs/relm4/latest/relm4/actions/struct.RelmActionGroup.html#method.register_for_widget"><code>RelmActionGroup::register_for_widget()</code></a> and <a href="https://docs.rs/relm4/latest/relm4/actions/struct.RelmActionGroup.html#method.register_for_main_application"><code>RelmActionGroup::register_for_main_application()</code></a> instead of <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/prelude/trait.WidgetExt.html#method.insert_action_group"><code>WidgetExt::insert_action_group()</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-from-v06-to-v07"><a class="header" href="#migration-from-v06-to-v07">Migration from v0.6 to v0.7</a></h1>
<h2 id="component-changes"><a class="header" href="#component-changes">Component changes</a></h2>
<p>Switching between the <code>Component</code> and <code>AsyncComponent</code> traits has been a bit unpleasant in previous versions due to complex errors generated by the code generated by <code>async-trait</code>.
To avoid this, the signatures of <code>Component</code> and <code>AsyncComponent</code> were unified.</p>
<p>This means, that <code>Component::init()</code> and <code>SimpleComponent::init()</code> now take <code>Self::Root</code> as owned parameter instead of a reference (<code>&amp;Self::Root</code>).
In most places, this just means that you have to remove a <code>&amp;</code>.</p>
<h2 id="factory-changes"><a class="header" href="#factory-changes">Factory changes</a></h2>
<p><code>ParentInput</code> and <code>forward_to_parent()</code> were removed from <code>FactoryComponent</code> and <code>AsyncFactoryComponent</code>.
Instead, factories now support basically the same builder pattern as components.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>Replace this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[relm4::factory]
impl FactoryComponent for Counter {
    type ParentInput = AppMsg;

    fn forward_to_parent(output: Self::Output) -&gt; Option&lt;AppMsg&gt; {
        Some(match output {
            CounterOutput::SendFront(index) =&gt; AppMsg::SendFront(index),
            CounterOutput::MoveUp(index) =&gt; AppMsg::MoveUp(index),
            CounterOutput::MoveDown(index) =&gt; AppMsg::MoveDown(index),
        })
    }

    // ...
}

#[relm4::component]
impl SimpleComponent for App {
    // ...

    fn init(
        counter: Self::Init,
        root: &amp;Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let counters = FactoryVecDeque::new(gtk::Box::default(), sender.input_sender());
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[relm4::component]
impl SimpleComponent for App {
    // ...

    fn init(
        counter: Self::Init,
        root: &amp;Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let counters = FactoryVecDeque::builder()
            .launch(gtk::Box::default())
            .forward(sender.input_sender(), |output| match output {
                CounterOutput::SendFront(index) =&gt; AppMsg::SendFront(index),
                CounterOutput::MoveUp(index) =&gt; AppMsg::MoveUp(index),
                CounterOutput::MoveDown(index) =&gt; AppMsg::MoveDown(index),
            });
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="other-changes"><a class="header" href="#other-changes">Other changes</a></h2>
<ul>
<li><code>set_global_css</code> and <code>set_global_css_from_file</code> are now methods of <code>RelmApp</code> to prevent calling them before initializing GTK</li>
<li>The <code>drawing</code> module was moved into the new <code>abstractions</code> module</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-from-v07-to-v08"><a class="header" href="#migration-from-v07-to-v08">Migration from v0.7 to v0.8</a></h1>
<p>Since 0.8 was released at the same day as 0.7, there are not many changes.
It is worth noting though, that the <code>async-trait</code> crate was removed in favor of regular async traits available since Rust 1.75.
This means that all manual uses of <code>#[async_trait]</code> for <code>AsyncComponent</code> or similar traits have to be removed.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
