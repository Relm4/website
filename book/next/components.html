<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Components - GUI development with Relm4</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="basic_concepts/index.html"><strong aria-hidden="true">1.</strong> Basic concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic_concepts/model.html"><strong aria-hidden="true">1.1.</strong> Model</a></li><li class="chapter-item expanded "><a href="basic_concepts/messages.html"><strong aria-hidden="true">1.2.</strong> Messages</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic_concepts/messages/input.html"><strong aria-hidden="true">1.2.1.</strong> Input</a></li><li class="chapter-item expanded "><a href="basic_concepts/messages/output.html"><strong aria-hidden="true">1.2.2.</strong> Output</a></li></ol></li><li class="chapter-item expanded "><a href="basic_concepts/widgets.html"><strong aria-hidden="true">1.3.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="basic_concepts/components.html"><strong aria-hidden="true">1.4.</strong> Components</a></li></ol></li><li class="chapter-item expanded "><a href="first_app.html"><strong aria-hidden="true">2.</strong> Your first app</a></li><li class="chapter-item expanded "><a href="component_macro.html"><strong aria-hidden="true">3.</strong> The component macro</a></li><li class="chapter-item expanded "><a href="tricks.html"><strong aria-hidden="true">4.</strong> Tips and tricks</a></li><li class="chapter-item expanded "><a href="efficient_ui/index.html"><strong aria-hidden="true">5.</strong> Efficient UI updates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="efficient_ui/tracker.html"><strong aria-hidden="true">5.1.</strong> Tracker</a></li><li class="chapter-item expanded "><a href="efficient_ui/factory.html"><strong aria-hidden="true">5.2.</strong> Factories</a></li><li class="chapter-item expanded "><a href="efficient_ui/factory_position.html"><strong aria-hidden="true">5.3.</strong> The position function</a></li></ol></li><li class="chapter-item expanded "><a href="components.html" class="active"><strong aria-hidden="true">6.</strong> Components</a></li><li class="chapter-item expanded "><a href="threads_and_async/index.html"><strong aria-hidden="true">7.</strong> Threads and async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threads_and_async/worker.html"><strong aria-hidden="true">7.1.</strong> Workers</a></li><li class="chapter-item expanded "><a href="threads_and_async/commands.html"><strong aria-hidden="true">7.2.</strong> Commands</a></li><li class="chapter-item expanded "><a href="threads_and_async/async.html"><strong aria-hidden="true">7.3.</strong> Async components and factories</a></li><li class="chapter-item expanded "><a href="threads_and_async/overview.html"><strong aria-hidden="true">7.4.</strong> Overview</a></li></ol></li><li class="chapter-item expanded "><a href="child_components.html"><strong aria-hidden="true">8.</strong> Child components</a></li><li class="chapter-item expanded "><a href="widget_templates/index.html"><strong aria-hidden="true">9.</strong> Widget templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="widget_templates/accessing_nested_template_elements.html"><strong aria-hidden="true">9.1.</strong> Accessing Nested Template Elements</a></li></ol></li><li class="chapter-item expanded "><a href="gtk_rs.html"><strong aria-hidden="true">10.</strong> gtk-rs overview</a></li><li class="chapter-item expanded "><a href="resource_bundles.html"><strong aria-hidden="true">11.</strong> Resource Bundles</a></li><li class="chapter-item expanded "><a href="continuous_integration.html"><strong aria-hidden="true">12.</strong> Continuous Integration guide</a></li><li class="chapter-item expanded "><a href="component_macro/reference.html"><strong aria-hidden="true">13.</strong> Component macro reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="component_macro/expansion.html"><strong aria-hidden="true">13.1.</strong> Macro expansion</a></li></ol></li><li class="chapter-item expanded "><a href="migrations/index.html"><strong aria-hidden="true">14.</strong> Migration guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="migrations/0_2_to_0_4.html"><strong aria-hidden="true">14.1.</strong> 0.2 to 0.4</a></li><li class="chapter-item expanded "><a href="migrations/0_4_to_0_5.html"><strong aria-hidden="true">14.2.</strong> 0.4 to 0.5</a></li><li class="chapter-item expanded "><a href="migrations/0_5_to_0_6.html"><strong aria-hidden="true">14.3.</strong> 0.5 to 0.6</a></li><li class="chapter-item expanded "><a href="migrations/0_6_to_0_7.html"><strong aria-hidden="true">14.4.</strong> 0.6 to 0.7</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Relm4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Relm4/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Relm4/book/edit/main/src/components.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>Technically, we already used components in the previous chapters.
So far, we've only used one component per application, but in this chapter, we're going to use multiple components to structure our app.</p>
<p>Components are independent parts of your application that can communicate with each other.
They are used in a parent-child model: The main app component can have several components and each component can have child components and so on.
This means that each component has a parent, except for the main app component which is at the top of this tree structure.</p>
<p>To showcase this, we will create a small application which opens a dialog when the user tries to close it.
The header bar and the dialog will be implemented as standalone components.</p>
<p><img src="img/screenshots/components-dark-1.png" alt="App screenshot dark" /></p>
<p><img src="img/screenshots/components-dark-2.png" alt="App screenshot dark" /></p>
<h2 id="when-to-use-components"><a class="header" href="#when-to-use-components">When to use components</a></h2>
<p>Components are very useful for separating parts of the UI into smaller, more manageable parts.
They are not necessary but for larger applications, they can be very helpful.</p>
<h2 id="message-handling"><a class="header" href="#message-handling">Message handling</a></h2>
<p>Components store their child components inside the model as a <code>Controller&lt;ChildModel&gt;</code> and handle output messages in the <code>init</code> function by calling the <code>forward</code> method.</p>
<pre><code class="language-rust no_run noplayground">        let header: Controller&lt;HeaderModel&gt; =
            HeaderModel::builder()
                .launch(())
                .forward(sender.input_sender(), |msg| match msg {
                    HeaderOutput::View =&gt; AppMsg::SetMode(AppMode::View),
                    HeaderOutput::Edit =&gt; AppMsg::SetMode(AppMode::Edit),
                    HeaderOutput::Export =&gt; AppMsg::SetMode(AppMode::Export),
                });</code></pre>
<p>The <code>forward</code> method will redirect the output messages from the child component and transform them into the parent's input messages.</p>
<blockquote>
<p>Components are independent from each another so a component can be used easily with several different parent components.
Therefore, the child component doesn't know which type its parent component will have.
Thus, the <code>forward</code> method allows the parent component to transform the output messages of child components to a message type it can handle properly.</p>
<p>In this example, <code>HeaderOutput</code> messages are translated into <code>AppMsg</code>.</p>
</blockquote>
<h1 id="example-application"><a class="header" href="#example-application">Example application</a></h1>
<p>Let's write a small example app to see how components can be used in action. For this example, we write parts of an app that can edit images.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/Relm4/Relm4/blob/main/examples/components.rs">here</a>. Run <code>cargo run --example components</code> from the <a href="https://github.com/Relm4/Relm4/tree/main/examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="the-header-bar"><a class="header" href="#the-header-bar">The header bar</a></h2>
<p>Our first component will be a header bar. There are not a lot of advantages for writing this as component except for reducing the complexity in other parts of our UI.</p>
<p>The header bar will have three buttons for three modes that our application can have:</p>
<ul>
<li><strong>View</strong>: View the image.</li>
<li><strong>Edit</strong>: Edit the image.</li>
<li><strong>Export</strong>: Export the image in different formats.</li>
</ul>
<p>We will not implement the actual functionality, but instead use placeholders to keep things simple.</p>
<h3 id="the-model"><a class="header" href="#the-model">The model</a></h3>
<p>Usually you want to store everything that affects only your component in the state of the component. However, in this case, there is no state that can be stored in the component, but only state that affects the root component (app). Therefore, we leave the model empty and only send messages to the root component.</p>
<pre><code class="language-rust no_run noplayground">struct HeaderModel;</code></pre>
<p>The message type allows us to switch between the modes.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum HeaderOutput {
    View,
    Edit,
    Export,
}</code></pre>
<p>Our component needs no <code>update</code> method, because the <code>view</code> can emit the component's output messages as part of its click signal handlers, as we will see in the next section.</p>
<h3 id="the-widgets"><a class="header" href="#the-widgets">The widgets</a></h3>
<p>There's nothing special about widgets of a child component. The only difference to the main app component is that the root widget doesn't need to be a <code>gtk::Window</code>. Instead, we use a <code>gtk::HeaderBar</code> here, but theoretically the root widget doesn't even need to be a widget at all (which can be useful in special cases).</p>
<pre><code class="language-rust no_run noplayground">    view! {
        #[root]
        gtk::HeaderBar {
            #[wrap(Some)]
            set_title_widget = &amp;gtk::Box {
                add_css_class: &quot;linked&quot;,
                #[name = &quot;group&quot;]
                gtk::ToggleButton {
                    set_label: &quot;View&quot;,
                    set_active: true,
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::View).unwrap()
                        }
                    },
                },
                gtk::ToggleButton {
                    set_label: &quot;Edit&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::Edit).unwrap()
                        }
                    },
                },
                gtk::ToggleButton {
                    set_label: &quot;Export&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::Export).unwrap()
                        }
                    },
                },
            }
        }
    }</code></pre>
<h2 id="the-close-alert"><a class="header" href="#the-close-alert">The close alert</a></h2>
<p>As with a normal application used to edit files, we want to notify the user before they accidentally close the application and discard all progress. For this — you might have guessed it already — we will use another component.</p>
<h3 id="the-model-1"><a class="header" href="#the-model-1">The model</a></h3>
<p>The state of the dialog only needs to store whether or not it's hidden.</p>
<pre><code class="language-rust no_run noplayground">struct DialogModel {
    hidden: bool,
}</code></pre>
<p>The message contains three options:</p>
<ul>
<li><strong>Show</strong> is used by the parent to display the dialog.</li>
<li><strong>Accept</strong> is used internally to indicate that the user agreed to close the application.</li>
<li><strong>Cancel</strong> is used internally to indicate that the user changes his mind and doesn't want to close the application.</li>
</ul>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum DialogInput {
    Show,
    Accept,
    Cancel,
}

#[derive(Debug)]
enum DialogOutput {
    Close,
}</code></pre>
<h3 id="the-widgets-1"><a class="header" href="#the-widgets-1">The widgets</a></h3>
<p>Unlike the last component, the <code>DialogModel</code> component doesn't send its output messages from a signal handler. Instead, the <code>response</code> signal handler sends <em>input</em> messages to itself, handles them in <code>update</code>, and then sends output messages if necessary. This is a common pattern for more complex components.</p>
<blockquote>
<p>If your component accepts non-internal inputs as well, you may want to mark the internal variants as <code>#[doc(hidden)]</code> so that users of your component know they're only intended for internal use.</p>
</blockquote>
<pre><code class="language-rust no_run noplayground">    view! {
        gtk::MessageDialog {
            set_modal: true,
            #[watch]
            set_visible: !model.hidden,
            set_text: Some(&quot;Do you want to close before saving?&quot;),
            set_secondary_text: Some(&quot;All unsaved changes will be lost&quot;),
            add_button: (&quot;Close&quot;, gtk::ResponseType::Accept),
            add_button: (&quot;Cancel&quot;, gtk::ResponseType::Cancel),
            connect_response[sender] =&gt; move |_, resp| {
                sender.input(if resp == gtk::ResponseType::Accept {
                    DialogInput::Accept
                } else {
                    DialogInput::Cancel
                })
            }
        }
    }</code></pre>
<p>In the <code>update</code> implementation, we match the input messages and emit an output if needed.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;mut self, msg: Self::Input, sender: ComponentSender&lt;Self&gt;) {
        match msg {
            DialogInput::Show =&gt; self.hidden = false,
            DialogInput::Accept =&gt; {
                self.hidden = true;
                sender.output(DialogOutput::Close).unwrap()
            }
            DialogInput::Cancel =&gt; self.hidden = true,
        }
    }</code></pre>
<h2 id="the-main-app"><a class="header" href="#the-main-app">The main app</a></h2>
<p>Now all parts come together to form a single app.</p>
<h3 id="the-model-2"><a class="header" href="#the-model-2">The model</a></h3>
<p>First, let's define the model of the main app and its messages.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum AppMode {
    View,
    Edit,
    Export,
}

#[derive(Debug)]
enum AppMsg {
    SetMode(AppMode),
    CloseRequest,
    Close,
}

struct AppModel {
    mode: AppMode,
    header: Controller&lt;HeaderModel&gt;,
    dialog: Controller&lt;DialogModel&gt;,
}</code></pre>
<p>The <code>AppMode</code> struct stores the modes the application can be in. The <code>SetMode</code> message is transformed from the output of our header bar component to update the state of the main application when someone presses a button in the header bar. The <code>Close</code> message is transformed from the output of the dialog component to indicate that the window should be closed.</p>
<p>In the model, we store the current <code>AppMode</code> as well as a <code>Controller</code> for each of our child components.</p>
<p>The update function of the model is pretty straightforward.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::SetMode(mode) =&gt; {
                self.mode = mode;
            }
            AppMsg::CloseRequest =&gt; {
                self.dialog.sender().send(DialogInput::Show).unwrap();
            }
            AppMsg::Close =&gt; {
                relm4::main_application().quit();
            }
        }
    }</code></pre>
<p>We can retrieve a sender for the child component by calling the <code>sender()</code> method on the associated <code>Controller</code>, and then send messages of the associated <code>Input</code> type through it.</p>
<h3 id="controllers"><a class="header" href="#controllers">Controllers</a></h3>
<p>When initializing the app component, we construct the child components by passing the appropriate <code>Init</code> and forwarding any desired inputs and outputs. This is done through a builder provided by <code>Component</code> implementations. We pass the initial parameters via the <code>launch</code> method, and then retrieve the final <code>Controller</code> by calling the <code>forward</code> method. In addition to starting the component, the <code>forward</code> method allows us to take the outputs of the component, transform them with a mapping function, and then pass the result as an input message to another sender (in this case, the input sender of the app component). If you don't need to forward any outputs, you can start the component with the <code>detach</code> method instead.</p>
<pre><code class="language-rust no_run noplayground">    fn init(
        params: Self::Init,
        root: &amp;Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let header: Controller&lt;HeaderModel&gt; =
            HeaderModel::builder()
                .launch(())
                .forward(sender.input_sender(), |msg| match msg {
                    HeaderOutput::View =&gt; AppMsg::SetMode(AppMode::View),
                    HeaderOutput::Edit =&gt; AppMsg::SetMode(AppMode::Edit),
                    HeaderOutput::Export =&gt; AppMsg::SetMode(AppMode::Export),
                });

        let dialog = DialogModel::builder()
            .transient_for(root)
            .launch(true)
            .forward(sender.input_sender(), |msg| match msg {
                DialogOutput::Close =&gt; AppMsg::Close,
            });

        let model = AppModel {
            mode: params,
            header,
            dialog,
        };

        let widgets = view_output!();
        ComponentParts { model, widgets }
    }</code></pre>
<p>Also, we set the <code>set_transient_for</code> property, which actually uses the main window. The dialog should set his parent window so that GTK can handle the dialog better. The GTK docs state: &quot;[set_transient_for] allows window managers to e.g. keep the dialog on top of the main window, or center the dialog over the main window&quot;.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum AppMode {
    View,
    Edit,
    Export,
}

#[derive(Debug)]
enum AppMsg {
    SetMode(AppMode),
    CloseRequest,
    Close,
}

struct AppModel {
    mode: AppMode,
    header: Controller&lt;HeaderModel&gt;,
    dialog: Controller&lt;DialogModel&gt;,
}</code></pre>
<h3 id="the-widgets-2"><a class="header" href="#the-widgets-2">The widgets</a></h3>
<p>We're almost done! Lastly, let's take a look at the app widgets.</p>
<pre><code class="language-rust no_run noplayground">    view! {
        main_window = gtk::Window {
            set_default_width: 500,
            set_default_height: 250,
            set_titlebar: Some(model.header.widget()),

            gtk::Label {
                #[watch]
                set_label: &amp;format!(&quot;Placeholder for {:?}&quot;, model.mode),
            },
            connect_close_request[sender] =&gt; move |_| {
                sender.input(AppMsg::CloseRequest);
                gtk::glib::Propagation::Stop
            }
        }
    }</code></pre>
<p>Most notably, we retrieve the root widget of our header component through the <code>widget()</code> method on the associated <code>Controller</code> to set it as a child of the main window.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>You now know most of the secrets that Relm4 offers. Components can be powerful and if they are implemented correctly, they are even reusable across different apps. The relm4-components crate offers several reusable components you can use in your applications. In the following chapters, we'll look at an even simpler component type called worker, how to implement reusable components yourself and how to use components with async code and multiple threads.</p>
<h2 id="the-complete-code"><a class="header" href="#the-complete-code">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{
    ApplicationExt, ButtonExt, DialogExt, GtkWindowExt, ToggleButtonExt, WidgetExt,
};
use relm4::*;

struct HeaderModel;

#[derive(Debug)]
enum HeaderOutput {
    View,
    Edit,
    Export,
}


#[relm4::component]
impl SimpleComponent for HeaderModel {
    type Init = ();
    type Input = ();
    type Output = HeaderOutput;

    view! {
        #[root]
        gtk::HeaderBar {
            #[wrap(Some)]
            set_title_widget = &amp;gtk::Box {
                add_css_class: &quot;linked&quot;,
                #[name = &quot;group&quot;]
                gtk::ToggleButton {
                    set_label: &quot;View&quot;,
                    set_active: true,
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::View).unwrap()
                        }
                    },
                },
                gtk::ToggleButton {
                    set_label: &quot;Edit&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::Edit).unwrap()
                        }
                    },
                },
                gtk::ToggleButton {
                    set_label: &quot;Export&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled[sender] =&gt; move |btn| {
                        if btn.is_active() {
                            sender.output(HeaderOutput::Export).unwrap()
                        }
                    },
                },
            }
        }
    }

    fn init(
        _params: Self::Init,
        root: &amp;Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let model = HeaderModel;
        let widgets = view_output!();
        ComponentParts { model, widgets }
    }
}


struct DialogModel {
    hidden: bool,
}

#[derive(Debug)]
enum DialogInput {
    Show,
    Accept,
    Cancel,
}

#[derive(Debug)]
enum DialogOutput {
    Close,
}

#[relm4::component]
impl SimpleComponent for DialogModel {
    type Init = bool;
    type Input = DialogInput;
    type Output = DialogOutput;

    view! {
        gtk::MessageDialog {
            set_modal: true,
            #[watch]
            set_visible: !model.hidden,
            set_text: Some(&quot;Do you want to close before saving?&quot;),
            set_secondary_text: Some(&quot;All unsaved changes will be lost&quot;),
            add_button: (&quot;Close&quot;, gtk::ResponseType::Accept),
            add_button: (&quot;Cancel&quot;, gtk::ResponseType::Cancel),
            connect_response[sender] =&gt; move |_, resp| {
                sender.input(if resp == gtk::ResponseType::Accept {
                    DialogInput::Accept
                } else {
                    DialogInput::Cancel
                })
            }
        }
    }

    fn init(
        params: Self::Init,
        root: &amp;Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let model = DialogModel { hidden: params };
        let widgets = view_output!();
        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, msg: Self::Input, sender: ComponentSender&lt;Self&gt;) {
        match msg {
            DialogInput::Show =&gt; self.hidden = false,
            DialogInput::Accept =&gt; {
                self.hidden = true;
                sender.output(DialogOutput::Close).unwrap()
            }
            DialogInput::Cancel =&gt; self.hidden = true,
        }
    }
}

#[derive(Debug)]
enum AppMode {
    View,
    Edit,
    Export,
}

#[derive(Debug)]
enum AppMsg {
    SetMode(AppMode),
    CloseRequest,
    Close,
}

struct AppModel {
    mode: AppMode,
    header: Controller&lt;HeaderModel&gt;,
    dialog: Controller&lt;DialogModel&gt;,
}

#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = AppMode;
    type Input = AppMsg;
    type Output = ();

    view! {
        main_window = gtk::Window {
            set_default_width: 500,
            set_default_height: 250,
            set_titlebar: Some(model.header.widget()),

            gtk::Label {
                #[watch]
                set_label: &amp;format!(&quot;Placeholder for {:?}&quot;, model.mode),
            },
            connect_close_request[sender] =&gt; move |_| {
                sender.input(AppMsg::CloseRequest);
                gtk::glib::Propagation::Stop
            }
        }
    }

    fn init(
        params: Self::Init,
        root: &amp;Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let header: Controller&lt;HeaderModel&gt; =
            HeaderModel::builder()
                .launch(())
                .forward(sender.input_sender(), |msg| match msg {
                    HeaderOutput::View =&gt; AppMsg::SetMode(AppMode::View),
                    HeaderOutput::Edit =&gt; AppMsg::SetMode(AppMode::Edit),
                    HeaderOutput::Export =&gt; AppMsg::SetMode(AppMode::Export),
                });

        let dialog = DialogModel::builder()
            .transient_for(root)
            .launch(true)
            .forward(sender.input_sender(), |msg| match msg {
                DialogOutput::Close =&gt; AppMsg::Close,
            });

        let model = AppModel {
            mode: params,
            header,
            dialog,
        };

        let widgets = view_output!();
        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::SetMode(mode) =&gt; {
                self.mode = mode;
            }
            AppMsg::CloseRequest =&gt; {
                self.dialog.sender().send(DialogInput::Show).unwrap();
            }
            AppMsg::Close =&gt; {
                relm4::main_application().quit();
            }
        }
    }
}

fn main() {
    let relm = RelmApp::new(&quot;ewlm4.test.components&quot;);
    relm.run::&lt;AppModel&gt;(AppMode::Edit);
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="efficient_ui/factory_position.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="threads_and_async/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="efficient_ui/factory_position.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="threads_and_async/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
