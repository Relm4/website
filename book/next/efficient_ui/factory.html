<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Factories - GUI development with Relm4</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="../basic_concepts/index.html"><strong aria-hidden="true">1.</strong> Basic concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_concepts/model.html"><strong aria-hidden="true">1.1.</strong> Model</a></li><li class="chapter-item expanded "><a href="../basic_concepts/messages.html"><strong aria-hidden="true">1.2.</strong> Messages</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic_concepts/messages/input.html"><strong aria-hidden="true">1.2.1.</strong> Input</a></li><li class="chapter-item expanded "><a href="../basic_concepts/messages/output.html"><strong aria-hidden="true">1.2.2.</strong> Output</a></li></ol></li><li class="chapter-item expanded "><a href="../basic_concepts/widgets.html"><strong aria-hidden="true">1.3.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="../basic_concepts/components.html"><strong aria-hidden="true">1.4.</strong> Components</a></li></ol></li><li class="chapter-item expanded "><a href="../first_app.html"><strong aria-hidden="true">2.</strong> Your first app</a></li><li class="chapter-item expanded "><a href="../component_macro.html"><strong aria-hidden="true">3.</strong> The component macro</a></li><li class="chapter-item expanded "><a href="../tricks.html"><strong aria-hidden="true">4.</strong> Tips and tricks</a></li><li class="chapter-item expanded "><a href="../efficient_ui/index.html"><strong aria-hidden="true">5.</strong> Efficient UI updates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../efficient_ui/tracker.html"><strong aria-hidden="true">5.1.</strong> Tracker</a></li><li class="chapter-item expanded "><a href="../efficient_ui/factory.html" class="active"><strong aria-hidden="true">5.2.</strong> Factories</a></li><li class="chapter-item expanded "><a href="../efficient_ui/factory_position.html"><strong aria-hidden="true">5.3.</strong> The position function</a></li></ol></li><li class="chapter-item expanded "><a href="../components.html"><strong aria-hidden="true">6.</strong> Components</a></li><li class="chapter-item expanded "><a href="../threads_and_async/index.html"><strong aria-hidden="true">7.</strong> Threads and async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../threads_and_async/worker.html"><strong aria-hidden="true">7.1.</strong> Workers</a></li><li class="chapter-item expanded "><a href="../threads_and_async/commands.html"><strong aria-hidden="true">7.2.</strong> Commands</a></li><li class="chapter-item expanded "><a href="../threads_and_async/async.html"><strong aria-hidden="true">7.3.</strong> Async components and factories</a></li><li class="chapter-item expanded "><a href="../threads_and_async/overview.html"><strong aria-hidden="true">7.4.</strong> Overview</a></li></ol></li><li class="chapter-item expanded "><a href="../child_components.html"><strong aria-hidden="true">8.</strong> Child components</a></li><li class="chapter-item expanded "><a href="../widget_templates/index.html"><strong aria-hidden="true">9.</strong> Widget templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../widget_templates/accessing_nested_template_elements.html"><strong aria-hidden="true">9.1.</strong> Accessing Nested Template Elements</a></li></ol></li><li class="chapter-item expanded "><a href="../gtk_rs.html"><strong aria-hidden="true">10.</strong> gtk-rs overview</a></li><li class="chapter-item expanded "><a href="../resource_bundles.html"><strong aria-hidden="true">11.</strong> Resource Bundles</a></li><li class="chapter-item expanded "><a href="../continuous_integration.html"><strong aria-hidden="true">12.</strong> Continuous Integration guide</a></li><li class="chapter-item expanded "><a href="../component_macro/reference.html"><strong aria-hidden="true">13.</strong> Component macro reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../component_macro/expansion.html"><strong aria-hidden="true">13.1.</strong> Macro expansion</a></li></ol></li><li class="chapter-item expanded "><a href="../migrations/index.html"><strong aria-hidden="true">14.</strong> Migration guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../migrations/0_2_to_0_4.html"><strong aria-hidden="true">14.1.</strong> 0.2 to 0.4</a></li><li class="chapter-item expanded "><a href="../migrations/0_4_to_0_5.html"><strong aria-hidden="true">14.2.</strong> 0.4 to 0.5</a></li><li class="chapter-item expanded "><a href="../migrations/0_5_to_0_6.html"><strong aria-hidden="true">14.3.</strong> 0.5 to 0.6</a></li><li class="chapter-item expanded "><a href="../migrations/0_6_to_0_7.html"><strong aria-hidden="true">14.4.</strong> 0.6 to 0.7</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Relm4</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Relm4/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Relm4/book/edit/main/src/efficient_ui/factory.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="factory"><a class="header" href="#factory">Factory</a></h1>
<p>Factories define how to generate widgets from data collections.
GTK also has factories, yet Relm4 uses its own factory implementation which is much easier to use in regular Rust code.</p>
<p><img src="../img/screenshots/factory-dark.png" alt="App screenshot dark" /></p>
<p>This app will have a dynamic number of counters.
Also, the counters can be moved up and down by the user.</p>
<h2 id="factories-in-relm4"><a class="header" href="#factories-in-relm4">Factories in Relm4</a></h2>
<p>Factories allow you to visualize data in a natural way.
If you wanted to store a set of counter values in regular Rust code, you'd probably use <code>Vec&lt;u8&gt;</code>.
However, you can't simply generate widgets from a <code>Vec</code>.</p>
<p>This is where factories are really useful.
Custom collection types like <code>FactoryVecDeque</code> allow you to work with collections of data almost as comfortable as if they were stored in a <code>Vec</code>.
At the same time, factories allow you to automatically visualize the data with widgets.
Additionally, factories are very efficient by reducing the amount of UI updates to a minimum.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/Relm4/Relm4/blob/main/examples/factory.rs">here</a>.
Run <code>cargo run --example factory</code> from the <a href="https://github.com/Relm4/Relm4/tree/main/examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h3 id="the-model"><a class="header" href="#the-model">The model</a></h3>
<p>First, we define the struct <code>Counter</code> that just stores the value of a single counter.
Later, we will use a <code>FactoryVecDeque</code> to store our counters.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
struct Counter {
    value: u8,
}</code></pre>
<h3 id="the-input-message-type"><a class="header" href="#the-input-message-type">The input message type</a></h3>
<p>Each counter should be able to increment and decrement.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum CounterMsg {
    Increment,
    Decrement,
}</code></pre>
<h3 id="the-output-message-type"><a class="header" href="#the-output-message-type">The output message type</a></h3>
<p>A neat feature of factories is that each element can easily forward their output messages to the input of their parent component.
For example, this is necessary for modifications that require access to the whole <code>FactoryVecDeque</code>, like moving an element to a new position.
Therefore, these actions are covered by the output type.</p>
<p>The actions we want to perform "from outside" are</p>
<ul>
<li>Move a counter up</li>
<li>Move a counter down</li>
<li>Move a counter to the first position</li>
</ul>
<p>Accordingly, our message type looks like this:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum CounterOutput {
    SendFront(DynamicIndex),
    MoveUp(DynamicIndex),
    MoveDown(DynamicIndex),
}</code></pre>
<p>You might wonder why <code>DynamicIndex</code> is used here.
First, the parent component needs to know which element should be moved, which is defined by the index.
Further, elements can move in the <code>FactoryVecDeque</code>.
If we used <code>usize</code> as index instead, it could happen that the index points to another element by the time it is processed.</p>
<h3 id="the-factory-implementation"><a class="header" href="#the-factory-implementation">The factory implementation</a></h3>
<p>Factories use the <code>FactoryComponent</code> trait which is very similar to regular components with some minor adjustments.
For example, <code>FactoryComponent</code> needs the <code>#[relm4::factory]</code> attribute macro and a few more associated types in the trait implementation.</p>
<pre><code class="language-rust no_run noplayground">#[relm4::factory]
impl FactoryComponent for Counter {
    type Init = u8;
    type Input = CounterMsg;
    type Output = CounterOutput;
    type CommandOutput = ();
    type ParentWidget = gtk::Box;</code></pre>
<p>Let's look at the associated types one by one:</p>
<ul>
<li><strong>Init</strong>: The data required to initialize <code>Counter</code>, in this case the initial counter value.</li>
<li><strong>Input</strong>: The input message type.</li>
<li><strong>Output</strong>: The output message type.</li>
<li><strong>CommandOutput</strong>: The command output message type, we don't need it here.</li>
<li><strong>ParentWidget</strong>: The container widget used to store the widgets of the factory, for example <code>gtk::Box</code>.</li>
</ul>
<h3 id="creating-the-widget"><a class="header" href="#creating-the-widget">Creating the widget</a></h3>
<p>The widget creation works as usual with our trusty <code>view</code> macro.
The only difference is that we use <code>self</code> to refer to the model due to differences in the <code>FactoryComponent</code> trait.</p>
<pre><code class="language-rust no_run noplayground">    view! {
        #[root]
        gtk::Box {
            set_orientation: gtk::Orientation::Horizontal,
            set_spacing: 10,

            #[name(label)]
            gtk::Label {
                #[watch]
                set_label: &amp;self.value.to_string(),
                set_width_chars: 3,
            },

            #[name(add_button)]
            gtk::Button {
                set_label: "+",
                connect_clicked =&gt; CounterMsg::Increment,
            },

            #[name(remove_button)]
            gtk::Button {
                set_label: "-",
                connect_clicked =&gt; CounterMsg::Decrement,
            },

            #[name(move_up_button)]
            gtk::Button {
                set_label: "Up",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::MoveUp(index.clone())).unwrap();
                }
            },

            #[name(move_down_button)]
            gtk::Button {
                set_label: "Down",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::MoveDown(index.clone())).unwrap();
                }
            },

            #[name(to_front_button)]
            gtk::Button {
                set_label: "To Start",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::SendFront(index.clone())).unwrap();
                }
            }
        }
    }</code></pre>
<h3 id="initializing-the-model"><a class="header" href="#initializing-the-model">Initializing the model</a></h3>
<p><code>FactoryComponent</code> has separate functions for initializing the model and the widgets.
This means, that we are a bit less flexible, but don't need <code>view_output!()</code> here.
Also, we just need to implement the <code>init_model</code> function because <code>init_widgets</code> is already implemented by the macro.</p>
<pre><code class="language-rust no_run noplayground">    fn init_model(value: Self::Init, _index: &amp;DynamicIndex, _sender: FactorySender&lt;Self&gt;) -&gt; Self {
        Self { value }
    }</code></pre>
<h2 id="the-main-component"><a class="header" href="#the-main-component">The main component</a></h2>
<p>Now, we have implemented the <code>FactoryComponent</code> type for the elements in our factory.
The only thing left to do is to write our main component to complete our app.</p>
<h3 id="the-component-types"><a class="header" href="#the-component-types">The component types</a></h3>
<p>For the main component we implement the familiar <code>SimpleComponent</code> trait.
First we define the model and the input message type and then start the trait implementation.</p>
<pre><code class="language-rust no_run noplayground">struct App {
    created_widgets: u8,
    counters: FactoryVecDeque&lt;Counter&gt;,
}

#[derive(Debug)]
enum AppMsg {
    AddCounter,
    RemoveCounter,
    SendFront(DynamicIndex),
    MoveUp(DynamicIndex),
    MoveDown(DynamicIndex),
}

#[relm4::component]
impl SimpleComponent for App {
    type Init = u8;
    type Input = AppMsg;
    type Output = ();</code></pre>
<h3 id="initializing-the-factory"><a class="header" href="#initializing-the-factory">Initializing the factory</a></h3>
<p>We skip the <code>view</code> macro for a moment and look at the <code>init</code> method.
You see that we are initializing the <code>FactoryVecDeque</code> using a builder pattern.
First, we call <code>FactoryVecDeque::builder()</code> to create the builder and use <code>launch()</code> to set the root widget of the factory.
This widget will store all the widgets created by the factory.</p>
<p>Then, we use the <code>forward()</code> method to pass all output messages of our factory (with type <code>CounterOutput</code>)  to the input of our component (with type <code>AppMsg</code>).</p>
<p>The last trick we have up our sleeves is to define a local variable <code>counter_box</code> that is a reference to the container widget of our factory.
We'll use it in the <code>view</code> macro in the next section.</p>
<pre><code class="language-rust no_run noplayground">    // Initialize the UI.
    fn init(
        counter: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let counters = FactoryVecDeque::builder()
            .launch(gtk::Box::default())
            .forward(sender.input_sender(), |output| match output {
                CounterOutput::SendFront(index) =&gt; AppMsg::SendFront(index),
                CounterOutput::MoveUp(index) =&gt; AppMsg::MoveUp(index),
                CounterOutput::MoveDown(index) =&gt; AppMsg::MoveDown(index),
            });

        let model = App {
            created_widgets: counter,
            counters,
        };

        let counter_box = model.counters.widget();
        let widgets = view_output!();

        ComponentParts { model, widgets }
    }</code></pre>
<h3 id="initializing-the-widgets"><a class="header" href="#initializing-the-widgets">Initializing the widgets</a></h3>
<p>The familiar <code>view</code> macro comes into play again.
Most things should look familiar, but this time we use a <code>#[local_ref]</code> attribute for the last widget to use the local variable we defined in the previous section.
This trick allows us to initialize the model with its <code>FactoryVecDeque</code> before the widgets, which is more convenient in most cases.</p>
<pre><code class="language-rust no_run noplayground">    view! {
        gtk::Window {
            set_title: Some("Factory example"),
            set_default_size: (300, 100),

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,
                set_spacing: 5,
                set_margin_all: 5,

                gtk::Button {
                    set_label: "Add counter",
                    connect_clicked =&gt; AppMsg::AddCounter,
                },

                gtk::Button {
                    set_label: "Remove counter",
                    connect_clicked =&gt; AppMsg::RemoveCounter,
                },

                #[local_ref]
                counter_box -&gt; gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 5,
                }
            }
        }
    }</code></pre>
<h3 id="the-main-update-function"><a class="header" href="#the-main-update-function">The main update function</a></h3>
<p>This time the main update function has actually quite a bit to do.
The code should be quite readable if you worked with <code>Vec</code> or <code>VecDeque</code> before.</p>
<p>One thing stands out though: We see a lot of calls to <code>guard()</code>.
In fact, all mutating methods of <code>FactoryVecDeque</code> need an RAII-guard.
This is similar to a <code>MutexGuard</code> you get from locking a mutex.</p>
<p>The reason for this is simple.
As long as the guard is alive, we can perform multiple operations.
Once we're done, we just drop the guard (or rather leave the current scope) and this will cause the factory to update its widgets automatically.
The neat thing: You can never forget to render changes, and the update algorithm can optimize widget updates for efficiency.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::AddCounter =&gt; {
                self.counters.guard().push_back(self.created_widgets);
                self.created_widgets = self.created_widgets.wrapping_add(1);
            }
            AppMsg::RemoveCounter =&gt; {
                self.counters.guard().pop_back();
            }
            AppMsg::SendFront(index) =&gt; {
                self.counters.guard().move_front(index.current_index());
            }
            AppMsg::MoveDown(index) =&gt; {
                let index = index.current_index();
                let new_index = index + 1;
                // Already at the end?
                if new_index &lt; self.counters.len() {
                    self.counters.guard().move_to(index, new_index);
                }
            }
            AppMsg::MoveUp(index) =&gt; {
                let index = index.current_index();
                // Already at the start?
                if index != 0 {
                    self.counters.guard().move_to(index, index - 1);
                }
            }
        }
    }</code></pre>
<h3 id="the-main-function"><a class="header" href="#the-main-function">The main function</a></h3>
<p>Awesome, we almost made it!</p>
<p>We only need to define the main function to run our application.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    let app = RelmApp::new("relm4.example.factory");
    app.run::&lt;App&gt;(0);
}</code></pre>
<h2 id="the-complete-code"><a class="header" href="#the-complete-code">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt, OrientableExt};
use relm4::factory::{DynamicIndex, FactoryComponent, FactorySender, FactoryVecDeque};
use relm4::{gtk, ComponentParts, ComponentSender, RelmApp, RelmWidgetExt, SimpleComponent};

#[derive(Debug)]
struct Counter {
    value: u8,
}

#[derive(Debug)]
enum CounterMsg {
    Increment,
    Decrement,
}

#[derive(Debug)]
enum CounterOutput {
    SendFront(DynamicIndex),
    MoveUp(DynamicIndex),
    MoveDown(DynamicIndex),
}

#[relm4::factory]
impl FactoryComponent for Counter {
    type Init = u8;
    type Input = CounterMsg;
    type Output = CounterOutput;
    type CommandOutput = ();
    type ParentWidget = gtk::Box;

    view! {
        #[root]
        gtk::Box {
            set_orientation: gtk::Orientation::Horizontal,
            set_spacing: 10,

            #[name(label)]
            gtk::Label {
                #[watch]
                set_label: &amp;self.value.to_string(),
                set_width_chars: 3,
            },

            #[name(add_button)]
            gtk::Button {
                set_label: "+",
                connect_clicked =&gt; CounterMsg::Increment,
            },

            #[name(remove_button)]
            gtk::Button {
                set_label: "-",
                connect_clicked =&gt; CounterMsg::Decrement,
            },

            #[name(move_up_button)]
            gtk::Button {
                set_label: "Up",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::MoveUp(index.clone())).unwrap();
                }
            },

            #[name(move_down_button)]
            gtk::Button {
                set_label: "Down",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::MoveDown(index.clone())).unwrap();
                }
            },

            #[name(to_front_button)]
            gtk::Button {
                set_label: "To Start",
                connect_clicked[sender, index] =&gt; move |_| {
                    sender.output(CounterOutput::SendFront(index.clone())).unwrap();
                }
            }
        }
    }

    fn init_model(value: Self::Init, _index: &amp;DynamicIndex, _sender: FactorySender&lt;Self&gt;) -&gt; Self {
        Self { value }
    }

    fn update(&amp;mut self, msg: Self::Input, _sender: FactorySender&lt;Self&gt;) {
        match msg {
            CounterMsg::Increment =&gt; {
                self.value = self.value.wrapping_add(1);
            }
            CounterMsg::Decrement =&gt; {
                self.value = self.value.wrapping_sub(1);
            }
        }
    }
}

struct App {
    created_widgets: u8,
    counters: FactoryVecDeque&lt;Counter&gt;,
}

#[derive(Debug)]
enum AppMsg {
    AddCounter,
    RemoveCounter,
    SendFront(DynamicIndex),
    MoveUp(DynamicIndex),
    MoveDown(DynamicIndex),
}

#[relm4::component]
impl SimpleComponent for App {
    type Init = u8;
    type Input = AppMsg;
    type Output = ();

    view! {
        gtk::Window {
            set_title: Some("Factory example"),
            set_default_size: (300, 100),

            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,
                set_spacing: 5,
                set_margin_all: 5,

                gtk::Button {
                    set_label: "Add counter",
                    connect_clicked =&gt; AppMsg::AddCounter,
                },

                gtk::Button {
                    set_label: "Remove counter",
                    connect_clicked =&gt; AppMsg::RemoveCounter,
                },

                #[local_ref]
                counter_box -&gt; gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 5,
                }
            }
        }
    }

    // Initialize the UI.
    fn init(
        counter: Self::Init,
        root: Self::Root,
        sender: ComponentSender&lt;Self&gt;,
    ) -&gt; ComponentParts&lt;Self&gt; {
        let counters = FactoryVecDeque::builder()
            .launch(gtk::Box::default())
            .forward(sender.input_sender(), |output| match output {
                CounterOutput::SendFront(index) =&gt; AppMsg::SendFront(index),
                CounterOutput::MoveUp(index) =&gt; AppMsg::MoveUp(index),
                CounterOutput::MoveDown(index) =&gt; AppMsg::MoveDown(index),
            });

        let model = App {
            created_widgets: counter,
            counters,
        };

        let counter_box = model.counters.widget();
        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&amp;mut self, msg: Self::Input, _sender: ComponentSender&lt;Self&gt;) {
        match msg {
            AppMsg::AddCounter =&gt; {
                self.counters.guard().push_back(self.created_widgets);
                self.created_widgets = self.created_widgets.wrapping_add(1);
            }
            AppMsg::RemoveCounter =&gt; {
                self.counters.guard().pop_back();
            }
            AppMsg::SendFront(index) =&gt; {
                self.counters.guard().move_front(index.current_index());
            }
            AppMsg::MoveDown(index) =&gt; {
                let index = index.current_index();
                let new_index = index + 1;
                // Already at the end?
                if new_index &lt; self.counters.len() {
                    self.counters.guard().move_to(index, new_index);
                }
            }
            AppMsg::MoveUp(index) =&gt; {
                let index = index.current_index();
                // Already at the start?
                if index != 0 {
                    self.counters.guard().move_to(index, index - 1);
                }
            }
        }
    }
}

fn main() {
    let app = RelmApp::new("relm4.example.factory");
    app.run::&lt;App&gt;(0);
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../efficient_ui/tracker.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../efficient_ui/factory_position.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../efficient_ui/tracker.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../efficient_ui/factory_position.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
